<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Vault Workshop 05: Authentication | Che-Chia Chang</title><meta name=keywords content="vault,iac,workshop,terraform,鐵人賽2023,chatgpt"><meta name=description content="如果你希望追蹤最新的草稿，請見鐵人賽2023
本 workshop 也接受網友的許願清單，如果有興趣的題目可於第一篇底下留言，筆者會盡力實現，但不做任何保證
整篇 Workshop 會使用的範例與原始碼，放在 Github Repository: vault-playground
Day 05：Authentication
在前面的文章中，你已經創建了第一個秘密，了解了秘密引擎，並在以開發模式啟動的 Vault 服務器中探索了動態秘密。
接下來的內容中，我們將深入研究使用 Vault token 和 GitHub 憑證進行身份驗證。
Token 身份驗證
Token 身份驗證已自動啟用。當你啟動開發模式服務器時，輸出顯示了 Root token。Vault CLI 從 $VAULT_TOKEN 環境變數中讀取 Root token。這個根 token 可以在 Vault 內執行任何操作，因為它被分配了 Root policy 權限。允許的權限中包含創建新的 token。
現在，讓我們創建一個新的 token。
啟動全新的 dev Vault Server
vault server -dev

output，server log 回傳 dev 模式的警告
WARNING! dev mode is enabled! In this mode, Vault runs entirely in-memory
and starts unsealed with a single unseal key. The root token is already
authenticated to the CLI, so you can immediately begin using Vault.

# 警告！已啟用開發模式！在此模式下，Vault完全運行在內存中，使用單個unseal key解封。
# root token已被CLI驗證，因此你可以立即開始使用Vault。

You may need to set the following environment variables:

    $ export VAULT_ADDR='http://127.0.0.1:8200'

# 以下顯示了unseal key 和 root token，以防你想要封存/解封Vault，或重新進行身份驗證。

    The unseal key and root token are displayed below in case you want to
    seal/unseal the Vault or re-authenticate.

# dev 模式預設配置的 unseal key 與 root token
    Unseal Key: QDUA...im4=
    Root Token: hvs.J30e...0DJaN

# 開發模式絕不應在生產安裝中使用！
    Development mode should NOT be used in production installations!

依據提示 export 需要的變數"><meta name=author content="chechiachang"><link rel=canonical href=https://chechia.net/posts/2023-09-16-vault-workshop-authentication/><meta name=google-site-verification content="G-QYR8JCDGM9"><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://chechia.net/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://chechia.net/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://chechia.net/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://chechia.net/favicon/favicon-32x32.png><link rel=mask-icon href=https://chechia.net/favicon/favicon-32x32.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://chechia.net/posts/2023-09-16-vault-workshop-authentication/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://chechia.net/posts/2023-09-16-vault-workshop-authentication/"><meta property="og:site_name" content="Che-Chia Chang"><meta property="og:title" content="Vault Workshop 05: Authentication"><meta property="og:description" content="如果你希望追蹤最新的草稿，請見鐵人賽2023
本 workshop 也接受網友的許願清單，如果有興趣的題目可於第一篇底下留言，筆者會盡力實現，但不做任何保證
整篇 Workshop 會使用的範例與原始碼，放在 Github Repository: vault-playground
Day 05：Authentication 在前面的文章中，你已經創建了第一個秘密，了解了秘密引擎，並在以開發模式啟動的 Vault 服務器中探索了動態秘密。
接下來的內容中，我們將深入研究使用 Vault token 和 GitHub 憑證進行身份驗證。
Token 身份驗證 Token 身份驗證已自動啟用。當你啟動開發模式服務器時，輸出顯示了 Root token。Vault CLI 從 $VAULT_TOKEN 環境變數中讀取 Root token。這個根 token 可以在 Vault 內執行任何操作，因為它被分配了 Root policy 權限。允許的權限中包含創建新的 token。
現在，讓我們創建一個新的 token。
啟動全新的 dev Vault Server
vault server -dev output，server log 回傳 dev 模式的警告
WARNING! dev mode is enabled! In this mode, Vault runs entirely in-memory and starts unsealed with a single unseal key. The root token is already authenticated to the CLI, so you can immediately begin using Vault. # 警告！已啟用開發模式！在此模式下，Vault完全運行在內存中，使用單個unseal key解封。 # root token已被CLI驗證，因此你可以立即開始使用Vault。 You may need to set the following environment variables: $ export VAULT_ADDR='http://127.0.0.1:8200' # 以下顯示了unseal key 和 root token，以防你想要封存/解封Vault，或重新進行身份驗證。 The unseal key and root token are displayed below in case you want to seal/unseal the Vault or re-authenticate. # dev 模式預設配置的 unseal key 與 root token Unseal Key: QDUA...im4= Root Token: hvs.J30e...0DJaN # 開發模式絕不應在生產安裝中使用！ Development mode should NOT be used in production installations! 依據提示 export 需要的變數"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-09-14T01:42:26+08:00"><meta property="article:modified_time" content="2023-09-14T01:42:26+08:00"><meta property="article:tag" content="Vault"><meta property="article:tag" content="Iac"><meta property="article:tag" content="Workshop"><meta property="article:tag" content="Terraform"><meta property="article:tag" content="鐵人賽2023"><meta property="article:tag" content="Chatgpt"><meta property="og:image" content="https://chechia.net/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://chechia.net/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Vault Workshop 05: Authentication"><meta name=twitter:description content="如果你希望追蹤最新的草稿，請見鐵人賽2023
本 workshop 也接受網友的許願清單，如果有興趣的題目可於第一篇底下留言，筆者會盡力實現，但不做任何保證
整篇 Workshop 會使用的範例與原始碼，放在 Github Repository: vault-playground
Day 05：Authentication
在前面的文章中，你已經創建了第一個秘密，了解了秘密引擎，並在以開發模式啟動的 Vault 服務器中探索了動態秘密。
接下來的內容中，我們將深入研究使用 Vault token 和 GitHub 憑證進行身份驗證。
Token 身份驗證
Token 身份驗證已自動啟用。當你啟動開發模式服務器時，輸出顯示了 Root token。Vault CLI 從 $VAULT_TOKEN 環境變數中讀取 Root token。這個根 token 可以在 Vault 內執行任何操作，因為它被分配了 Root policy 權限。允許的權限中包含創建新的 token。
現在，讓我們創建一個新的 token。
啟動全新的 dev Vault Server
vault server -dev

output，server log 回傳 dev 模式的警告
WARNING! dev mode is enabled! In this mode, Vault runs entirely in-memory
and starts unsealed with a single unseal key. The root token is already
authenticated to the CLI, so you can immediately begin using Vault.

# 警告！已啟用開發模式！在此模式下，Vault完全運行在內存中，使用單個unseal key解封。
# root token已被CLI驗證，因此你可以立即開始使用Vault。

You may need to set the following environment variables:

    $ export VAULT_ADDR='http://127.0.0.1:8200'

# 以下顯示了unseal key 和 root token，以防你想要封存/解封Vault，或重新進行身份驗證。

    The unseal key and root token are displayed below in case you want to
    seal/unseal the Vault or re-authenticate.

# dev 模式預設配置的 unseal key 與 root token
    Unseal Key: QDUA...im4=
    Root Token: hvs.J30e...0DJaN

# 開發模式絕不應在生產安裝中使用！
    Development mode should NOT be used in production installations!

依據提示 export 需要的變數"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://chechia.net/posts/"},{"@type":"ListItem","position":2,"name":"Vault Workshop 05: Authentication","item":"https://chechia.net/posts/2023-09-16-vault-workshop-authentication/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Vault Workshop 05: Authentication","name":"Vault Workshop 05: Authentication","description":"如果你希望追蹤最新的草稿，請見鐵人賽2023\n本 workshop 也接受網友的許願清單，如果有興趣的題目可於第一篇底下留言，筆者會盡力實現，但不做任何保證\n整篇 Workshop 會使用的範例與原始碼，放在 Github Repository: vault-playground\nDay 05：Authentication 在前面的文章中，你已經創建了第一個秘密，了解了秘密引擎，並在以開發模式啟動的 Vault 服務器中探索了動態秘密。\n接下來的內容中，我們將深入研究使用 Vault token 和 GitHub 憑證進行身份驗證。\nToken 身份驗證 Token 身份驗證已自動啟用。當你啟動開發模式服務器時，輸出顯示了 Root token。Vault CLI 從 $VAULT_TOKEN 環境變數中讀取 Root token。這個根 token 可以在 Vault 內執行任何操作，因為它被分配了 Root policy 權限。允許的權限中包含創建新的 token。\n現在，讓我們創建一個新的 token。\n啟動全新的 dev Vault Server\nvault server -dev output，server log 回傳 dev 模式的警告\nWARNING! dev mode is enabled! In this mode, Vault runs entirely in-memory and starts unsealed with a single unseal key. The root token is already authenticated to the CLI, so you can immediately begin using Vault. # 警告！已啟用開發模式！在此模式下，Vault完全運行在內存中，使用單個unseal key解封。 # root token已被CLI驗證，因此你可以立即開始使用Vault。 You may need to set the following environment variables: $ export VAULT_ADDR='http://127.0.0.1:8200' # 以下顯示了unseal key 和 root token，以防你想要封存/解封Vault，或重新進行身份驗證。 The unseal key and root token are displayed below in case you want to seal/unseal the Vault or re-authenticate. # dev 模式預設配置的 unseal key 與 root token Unseal Key: QDUA...im4= Root Token: hvs.J30e...0DJaN # 開發模式絕不應在生產安裝中使用！ Development mode should NOT be used in production installations! 依據提示 export 需要的變數\n","keywords":["vault","iac","workshop","terraform","鐵人賽2023","chatgpt"],"articleBody":"如果你希望追蹤最新的草稿，請見鐵人賽2023\n本 workshop 也接受網友的許願清單，如果有興趣的題目可於第一篇底下留言，筆者會盡力實現，但不做任何保證\n整篇 Workshop 會使用的範例與原始碼，放在 Github Repository: vault-playground\nDay 05：Authentication 在前面的文章中，你已經創建了第一個秘密，了解了秘密引擎，並在以開發模式啟動的 Vault 服務器中探索了動態秘密。\n接下來的內容中，我們將深入研究使用 Vault token 和 GitHub 憑證進行身份驗證。\nToken 身份驗證 Token 身份驗證已自動啟用。當你啟動開發模式服務器時，輸出顯示了 Root token。Vault CLI 從 $VAULT_TOKEN 環境變數中讀取 Root token。這個根 token 可以在 Vault 內執行任何操作，因為它被分配了 Root policy 權限。允許的權限中包含創建新的 token。\n現在，讓我們創建一個新的 token。\n啟動全新的 dev Vault Server\nvault server -dev output，server log 回傳 dev 模式的警告\nWARNING! dev mode is enabled! In this mode, Vault runs entirely in-memory and starts unsealed with a single unseal key. The root token is already authenticated to the CLI, so you can immediately begin using Vault. # 警告！已啟用開發模式！在此模式下，Vault完全運行在內存中，使用單個unseal key解封。 # root token已被CLI驗證，因此你可以立即開始使用Vault。 You may need to set the following environment variables: $ export VAULT_ADDR='http://127.0.0.1:8200' # 以下顯示了unseal key 和 root token，以防你想要封存/解封Vault，或重新進行身份驗證。 The unseal key and root token are displayed below in case you want to seal/unseal the Vault or re-authenticate. # dev 模式預設配置的 unseal key 與 root token Unseal Key: QDUA...im4= Root Token: hvs.J30e...0DJaN # 開發模式絕不應在生產安裝中使用！ Development mode should NOT be used in production installations! 依據提示 export 需要的變數\nexport VAULT_ADDR='http://127.0.0.1:8200' 在 dev mode 下，未使用 token 也可以存取 Vault Server 中的資料，這是因為 vault server 在啟用時，預設使用 token helper，將 root token 寫入到 local filesystem\nVault token helper 說明\n你可以使用以下指令，檢查儲存於本地的 vault token\ncat ~/.vault-token output\nhvs.J30e...0DJaN% vault CLI 自動取用本地儲存的 root token，所以已經自動完成 authentication，不用額外進行 authentication，也可以使用 Vault\n使用 Vault 時，須額外注意本地儲存的 token\n避免 dev 模式下儲存 root token Vault dev server 自動寫入 root token，讓開發 Vault 功能時十分便利。然而在資訊安全的領域，便利往往代表著風險。在非 dev Server 環境中，我們會嚴格控制所有 token 的曝險程度，特別是 root token，根本不該被 print 出，當然也萬萬不能儲存在本地電腦。\n依據你的開發需求，你可能不希望 dev 模式下，long-live 永久有效的 root token 儲存在本地電腦中，你可以使用 -dev-no-store-token flag 來避免 Vault dev server 暴露 root token。\nvault server -dev -dev-no-store-token output\nWARNING! dev mode is enabled! In this mode, Vault runs entirely in-memory and starts unsealed with a single unseal key. The root token is already authenticated to the CLI, so you can immediately begin using Vault. You may need to set the following environment variables: $ export VAULT_ADDR='http://127.0.0.1:8200' The unseal key and root token are displayed below in case you want to seal/unseal the Vault or re-authenticate. Unseal Key: hNi8T3YctTZrLYlKezLAJttfiF97D1Vy7Tq+HMM3y9w= Root Token: hvs.qCqY...p89KYv Development mode should NOT be used in production installations! 你可以檢查本地使否有儲存的的 vault token\ncat ~/.vault-token output\ncat: /Users/che-chia/.vault-token: No such file or directory 然後試圖在沒有 .vault-token 的狀態下，存取 Vault Server\nvault secrets list output，沒有合法的 access token，Vault server 回傳 403 權限被拒\nvault secrets list Error listing secrets engines: Error making API request. URL: GET http://127.0.0.1:8200/v1/sys/mounts Code: 403. Errors: * permission denied Authentication 你可以使用 vault dev Server log 中回傳的 root token 來存取 Vault server\n你可以將 token 在寫回 .vault-token，這是最方便，也最危險\n建議：永遠不要儲存 root token 在本地電腦上。非常容易遺忘自己本地有儲存 root token。\necho hvs.qCqY...p89KYv \u003e ~/.vault-token 另一個方式是使用環境變數 VAULT_TOKEN\nVAULT_TOKEN=hvs.qCqY...p89KYv vault secrets list 上面是在 CLI 前面插入環境變數，下面是 export VAULT_TOKEN 到當前 session 的環境變數\nexport VAULT_TOKEN=hvs.qCqY...p89KYv vault secrets list output\nPath Type Accessor Description ---- ---- -------- ----------- cubbyhole/ cubbyhole cubbyhole_9cc57bcf per-token private secret storage identity/ identity identity_41faabef identity store secret/ kv kv_fca914b5 key/value secret storage sys/ system system_5dd83198 system endpoints used for control, policy and debugging 你可以檢查目前環境變數中，與 Vault 有關的 env\nenv | grep VAULT output\nVAULT_ADDR=http://127.0.0.1:8200 VAULT_TOKEN=hvs.qCqY...p89KYv 當然，VAULT_TOKEN 的存在時間越久，token 曝險的機率就越高。\n也很容易忘記 VAULT_TOKEN 有存在的環境變數。\nVAULT TOKEN 雷點 workshop 至今，你目前只有一台 vault dev server，而且裡面並沒有任何的機密資料，這個 vault server 可以隨時拋棄。\n然而，在實務上，Vault 管理員手上可能會有多個 Vault server 需要管理。\n想像你有 dev / stag / prod 的 server，某一天你正在 dev 開發一個新功能，由於本地有 VAULT_TOKEN 與 VAULT_ADDR，你不疑有他的在這台 server 上運行許多測試的指令，包含新增一對測試 secret，刪刪改改現有的 secret。\n然後你的本能忽然覺得怪怪的，我沒有設置任何 vault env，為何可以直接存取 dev server？\n你拉出 env 看，發現是 production server 的 addr + token，上次進入 production server 時的 session，還存有有效的 addr 與 token\nVAULT_ADDR=http://vault.prod.chechia.net VAULT_TOKEN=this-is-prod-token 你麻煩大了\n心得：永遠不要儲存長效期的 token 在本地。本 workshop 會不斷地強調，提醒各種操作中的資安風險，請各位學習過程中就養成良好習慣，以免方便一時，遺憾終身。\nroot token https://developer.hashicorp.com/vault/docs/concepts/tokens#root-tokens\nroot token是附帶root policy的token。root token可以在Vault中執行任何操作。任何操作。\n此外，它們是Vault中唯一可以設置為永不過期，且無需進行任何續訂的 token 類型。由於 root token 權限如此大，Vault 設計上刻意讓創建root token 很困難；實際上只有三種方法可以創建root token：\n在 vault operator init 時生成的初始root token - 此token不會過期\n使用另一個root token 創建 root token。這點有個限制：使用有限期的root token，無法創建永不過期的root token\n在擁有 unseal keys quorum的權限下，使用 vault operator generate-root 來創建root token\nroot token在開發中很有用，但在 production 環境中應該非常謹慎使用。\n事實上，Vault團隊建議 root token 只能進行必要的初始設置，通常是設置身份驗證方法(auth method)，和必要的 policy，以允許管理員獲取更有限的token。或是緊急情況下使用root token，並在不再需要時立即撤銷(revoke)。\n如果需要新的root token，可以使用 operator generate-root 指令，使用相關的 API endpoint即時生成。\n同時，當root token處於活動狀態時，建議團隊中提供多人一起協作，共同檢查 terminal session，養成一種良好的安全實踐。這樣多人可以驗證使用root token執行的任務，以及這些任務完成後，立即撤銷了該token。\n使用 root token 產生 short-live token root token 預設配置 root policy，我們可以產生權限較小的 token，並指配置最小必要權限(least privilege)\nVAULT_TOKEN=hvs.qCqY...p89KYv vault token create Key Value --- ----- token hvs.FbAeX...kjBIp token_accessor rPOOSI06WGnFo9MVOvS8luhn token_duration ∞ token_renewable false token_policies [\"root\"] identity_policies [] policies [\"root\"] 已創建token，輸出中以key value的表格描述了此token。創建的token在此處顯示為 hvs.FbAeX…kjBIp\n此token是root token的子token，並且預設情況下，它會繼承其 parent token的policy 權限。\ntoken是核心身份驗證方法(core auth method)。你可以使用生成的token來 login Vault，只需在提示時複製並粘貼即可。\n你可以使用以下指令登入 vault\nvault login 在回傳的輸入令中輸入新產生的 child token hvs.FbAeX…kjBIp\nWARNING! The VAULT_TOKEN environment variable is set! The value of this variable will take precedence; if this is unwanted please unset VAULT_TOKEN or update its value accordingly. # 警告！已設置 VAULT_TOKEN 環境變數！此變數的值將優先考慮；如果不需要此設置，請取消設置 VAULT TOKEN 或相應地更新其值。 由於在前面的操作中，環境變數中仍帶有 VAULT_TOKEN，而且是更高權限的永不過期 root token，vault CLI 偵測到 VAULT TOKEN env，跳出警告。\n你可以透過以下指令清除 VAULT_TOKEN 環境變數\nunset VAULT_TOKEN 然後再次執行 vault login，在回傳的輸入令中輸入新產生的 child token hvs.FbAeX…kjBIp\nvault login output，顯示成功登入，並回傳 token 的相關訊息\nToken (will be hidden): Success! You are now authenticated. The token information displayed below is already stored in the token helper. You do NOT need to run \"vault login\" again. Future Vault requests will automatically use this token. Key Value --- ----- token hvs.FbAeX...kjBIp token_accessor rPOOSI06WGnFo9MVOvS8luhn token_duration ∞ token_renewable false token_policies [\"root\"] identity_policies [] policies [\"root\"] 此token是root token的子token，繼承其 parent token的policy 權限，也就是 root。本身是無效期限制的永久 root token。\n在創建一把 token，此時由於 vault login，進入登入狀態，token 已經存在本地中\nvault token create output，第二隻 token 為 hvs.FDjvyRFXo…QVFG。每一隻 token 都是不重複的。\nKey Value --- ----- token hvs.FDjvyRFXo...QVFG token_accessor gLe7IrUMUq4eb2pZWVdUhbHv token_duration ∞ token_renewable false token_policies [\"root\"] identity_policies [] policies [\"root\"] revoke 撤銷 token 當我們不再需要使用 token 時，最好盡快撤銷 revoke token\n目前的 token 樹狀結構\n初始 root token (啟動 dev Server 時預設產生的)\nchild: hvs.FbAeX…kjBIp grandchild: hvs.FDjvyRFXo…QVFG 你可以使用指令，撤銷第一把產生的 token (child)\nvault token revoke hvs.FbAeX...kjBIp CLI output，顯示 token 已經撤銷\nSuccess! Revoked token (if it existed) 同時，vault server log 紀錄 revoked lease\n2023-09-16T21:29:21.464+0800 [INFO] expiration: revoked lease: lease_id=auth/token/create/hf153f5e80ed722f6816f592032a43906a5606a889bab4c13ff3368c9a1b95b69 還記得我們是使用地一把產生的 token (child) login 的嗎？目前的登入當然也隨著 token 失效，嘗試存取回傳 403 權限被拒\nvault secrets list Error listing secrets engines: Error making API request. URL: GET http://127.0.0.1:8200/v1/sys/mounts Code: 403. Errors: * permission denied 嘗試重新 login，使用地一把產生的 token (child) 一樣被拒\nvault login output\nToken (will be hidden): Error authenticating: error looking up token: Error making API request. URL: GET http://127.0.0.1:8200/v1/auth/token/lookup-self Code: 403. Errors: * permission denied 撤銷token 時，也會一併撤銷使用這把 token 產生的子 token (grandchild)\n嘗試重新 login，使用第二把產生的 token (grandchild) 一樣被拒\nvault login output\nToken (will be hidden): Error authenticating: error looking up token: Error making API request. URL: GET http://127.0.0.1:8200/v1/auth/token/lookup-self Code: 403. Errors: * permission denied 為何總是要使用 root token 上面講了 vault 核心的 token auth method，相信讀者一定有一個奇怪的感覺\n最開始 login 需要 token 產生 token 在去產生新的 token 這樣產生 token 的 admin 不就需要將 token 先傳給使用者，使用者才能登入嗎？這樣傳遞 token 的行為，不是反而增加更大的曝險。\n這樣真的有比一般使用 username password 登入的方法更安全嗎？\n上面的想法都是有道理的，也就是說，光使用 token auth methods 是無法滿足我們的安全需求。這些安全需求，需要使用其他 auth method 方法來解決，而 vault 強大之處便是支援的許多 auth method，將 vault 的安全建立在其他更穩定的服務上，例如 github / aws / azure / gcp / kubernetes 等。\n下一篇，我們就來實作 github auth method。\nchatGPT 本段部分內容使用 chatGPT-3.5 翻譯 https://developer.hashicorp.com/vault/tutorials/getting-started/getting-started-authentication 內容，並由筆者人工校驗\nbase context\n我希望你能充當一名繁體中文翻譯，拼寫修正者和改進者。我將用英文與程式語言與你對話，你將翻譯它，並以已糾正且改進的版本回答，以繁體中文表達。我希望你能用更美麗和優雅、高級的繁體中文詞語和句子替換我簡化的詞語和句子。保持意義不變。我只希望你回答糾正和改進，不要寫解釋。 不要使用敬語，翻譯結果中若出現\"您\"，請用\"你\"取代\"您\"。 result correction\n部分英文內容為專有名詞，產生的繁體中文翻譯結果中，這些名詞維持英文，不需要翻譯成中文：key，value，certificate，token，policy，policy rule，path，path-based，key rolling，audit，audit trail，plain text，key value，Consul，S3 bucket，Leasing，Renewal，binary，prefix，instance，metadata。 修正下列翻譯：將 \"數據\" 改為 \"資料\"，將 \"數據庫\" 改為 \"資料庫\"，將 \"數據\" 改為 \"資料\"，將 \"訪問\" 改為 \"存取\"，將 \"源代碼\" 改為 \"原始碼\"，將 \"信息\" 改為 \"資訊\"，將 \"命令\" 改為 \"指令\"，將 \"禁用\" 改為 \"停用\"，將 \"默認\" 改為 \"預設\"。 ","wordCount":"1069","inLanguage":"en","image":"https://chechia.net/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2023-09-14T01:42:26+08:00","dateModified":"2023-09-14T01:42:26+08:00","author":{"@type":"Person","name":"chechiachang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://chechia.net/posts/2023-09-16-vault-workshop-authentication/"},"publisher":{"@type":"Organization","name":"Che-Chia Chang","logo":{"@type":"ImageObject","url":"https://chechia.net/favicon/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://chechia.net/ accesskey=h title="Home (Alt + H)"><img src=https://chechia.net/favicon/favicon-32x32.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://chechia.net/#posts title=Posts><span>Posts</span></a></li><li><a href=https://mvp.microsoft.com/zh-TW/mvp/profile/e407d0b9-5c01-eb11-a815-000d3a8ccaf5 title=MVP><span>MVP</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://chechia.net/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://chechia.net/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://chechia.net/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://chechia.net/>Home</a>&nbsp;»&nbsp;<a href=https://chechia.net/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Vault Workshop 05: Authentication</h1><div class=post-meta><span title='2023-09-14 01:42:26 +0800 CST'>September 14, 2023</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1069 words&nbsp;·&nbsp;chechiachang&nbsp;|&nbsp;<a href=https://github.com/chechiachang.github.io-src/content/posts/2023-09-16-vault-workshop-authentication/index.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><ul><li><a href=#token-身份驗證>Token 身份驗證</a></li><li><a href=#避免-dev-模式下儲存-root-token>避免 dev 模式下儲存 root token</a></li><li><a href=#authentication>Authentication</a></li><li><a href=#vault-token-雷點>VAULT TOKEN 雷點</a></li><li><a href=#root-token>root token</a></li><li><a href=#使用-root-token-產生-short-live-token>使用 root token 產生 short-live token</a></li><li><a href=#revoke-撤銷-token>revoke 撤銷 token</a></li><li><a href=#為何總是要使用-root-token>為何總是要使用 root token</a></li><li><a href=#chatgpt>chatGPT</a></li></ul></li></ul></nav></div></details></div><div class=post-content><p>如果你希望追蹤最新的草稿，請見<a href=https://chechia.net/zh-hant/tag/%E9%90%B5%E4%BA%BA%E8%B3%BD2023/>鐵人賽2023</a></p><p>本 workshop 也接受網友的許願清單，<a href=https://ithelp.ithome.com.tw/articles/10317378>如果有興趣的題目可於第一篇底下留言</a>，筆者會盡力實現，但不做任何保證</p><p>整篇 Workshop 會使用的範例與原始碼，放在 <a href=http://chechia.net/zh-hant/#projects>Github Repository: vault-playground</a></p><h1 id=day-05authentication>Day 05：Authentication<a hidden class=anchor aria-hidden=true href=#day-05authentication>#</a></h1><p>在前面的文章中，你已經創建了第一個秘密，了解了秘密引擎，並在以開發模式啟動的 Vault 服務器中探索了動態秘密。</p><p>接下來的內容中，我們將深入研究使用 Vault token 和 GitHub 憑證進行身份驗證。</p><h3 id=token-身份驗證>Token 身份驗證<a hidden class=anchor aria-hidden=true href=#token-身份驗證>#</a></h3><p>Token 身份驗證已自動啟用。當你啟動開發模式服務器時，輸出顯示了 Root token。Vault CLI 從 <code>$VAULT_TOKEN</code> 環境變數中讀取 Root token。這個根 token 可以在 Vault 內執行任何操作，因為它被分配了 Root policy 權限。允許的權限中包含創建新的 token。</p><p>現在，讓我們創建一個新的 token。</p><p>啟動全新的 dev Vault Server</p><pre><code class=language-bash>vault server -dev
</code></pre><p>output，server log 回傳 dev 模式的警告</p><pre><code>WARNING! dev mode is enabled! In this mode, Vault runs entirely in-memory
and starts unsealed with a single unseal key. The root token is already
authenticated to the CLI, so you can immediately begin using Vault.

# 警告！已啟用開發模式！在此模式下，Vault完全運行在內存中，使用單個unseal key解封。
# root token已被CLI驗證，因此你可以立即開始使用Vault。

You may need to set the following environment variables:

    $ export VAULT_ADDR='http://127.0.0.1:8200'

# 以下顯示了unseal key 和 root token，以防你想要封存/解封Vault，或重新進行身份驗證。

    The unseal key and root token are displayed below in case you want to
    seal/unseal the Vault or re-authenticate.

# dev 模式預設配置的 unseal key 與 root token
    Unseal Key: QDUA...im4=
    Root Token: hvs.J30e...0DJaN

# 開發模式絕不應在生產安裝中使用！
    Development mode should NOT be used in production installations!
</code></pre><p>依據提示 export 需要的變數</p><pre><code>export VAULT_ADDR='http://127.0.0.1:8200'
</code></pre><p>在 dev mode 下，未使用 token 也可以存取 Vault Server 中的資料，這是因為 vault server 在啟用時，預設使用 token helper，將 root token 寫入到 local filesystem</p><p><a href=https://developer.hashicorp.com/vault/docs/commands/token-helper>Vault token helper 說明</a></p><p>你可以使用以下指令，檢查儲存於本地的 vault token</p><pre><code class=language-bash>cat ~/.vault-token
</code></pre><p>output</p><pre><code class=language-bash>hvs.J30e...0DJaN%
</code></pre><p>vault CLI 自動取用本地儲存的 root token，所以已經自動完成 authentication，不用額外進行 authentication，也可以使用 Vault</p><p>使用 Vault 時，須額外注意本地儲存的 token</p><h3 id=避免-dev-模式下儲存-root-token>避免 dev 模式下儲存 root token<a hidden class=anchor aria-hidden=true href=#避免-dev-模式下儲存-root-token>#</a></h3><p>Vault dev server 自動寫入 root token，讓開發 Vault 功能時十分便利。然而在資訊安全的領域，便利往往代表著風險。在非 dev Server 環境中，我們會嚴格控制所有 token 的曝險程度，特別是 root token，根本不該被 print 出，當然也萬萬不能儲存在本地電腦。</p><p>依據你的開發需求，你可能不希望 dev 模式下，long-live 永久有效的 root token 儲存在本地電腦中，你可以使用 -dev-no-store-token flag 來避免 Vault dev server 暴露 root token。</p><pre><code class=language-bash>vault server -dev -dev-no-store-token
</code></pre><p>output</p><pre><code class=language-bash>WARNING! dev mode is enabled! In this mode, Vault runs entirely in-memory
and starts unsealed with a single unseal key. The root token is already
authenticated to the CLI, so you can immediately begin using Vault.

You may need to set the following environment variables:

    $ export VAULT_ADDR='http://127.0.0.1:8200'

The unseal key and root token are displayed below in case you want to
seal/unseal the Vault or re-authenticate.

Unseal Key: hNi8T3YctTZrLYlKezLAJttfiF97D1Vy7Tq+HMM3y9w=
Root Token: hvs.qCqY...p89KYv

Development mode should NOT be used in production installations!
</code></pre><p>你可以檢查本地使否有儲存的的 vault token</p><pre><code class=language-bash>cat ~/.vault-token
</code></pre><p>output</p><pre><code class=language-bash>cat: /Users/che-chia/.vault-token: No such file or directory
</code></pre><p>然後試圖在沒有 .vault-token 的狀態下，存取 Vault Server</p><pre><code class=language-bash>vault secrets list
</code></pre><p>output，沒有合法的 access token，Vault server 回傳 403 權限被拒</p><pre><code class=language-bash>vault secrets list
Error listing secrets engines: Error making API request.

URL: GET http://127.0.0.1:8200/v1/sys/mounts
Code: 403. Errors:

* permission denied
</code></pre><h3 id=authentication>Authentication<a hidden class=anchor aria-hidden=true href=#authentication>#</a></h3><p>你可以使用 vault dev Server log 中回傳的 root token 來存取 Vault server</p><p>你可以將 token 在寫回 .vault-token，這是最方便，也最危險</p><p>建議：永遠不要儲存 root token 在本地電腦上。非常容易遺忘自己本地有儲存 root token。</p><pre><code class=language-bash>echo hvs.qCqY...p89KYv &gt; ~/.vault-token
</code></pre><p>另一個方式是使用環境變數 <code>VAULT_TOKEN</code></p><pre><code class=language-bash>VAULT_TOKEN=hvs.qCqY...p89KYv vault secrets list
</code></pre><p>上面是在 CLI 前面插入環境變數，下面是 export <code>VAULT_TOKEN</code> 到當前 session 的環境變數</p><pre><code class=language-bash>export VAULT_TOKEN=hvs.qCqY...p89KYv
vault secrets list
</code></pre><p>output</p><pre><code class=language-bash>Path          Type         Accessor              Description
----          ----         --------              -----------
cubbyhole/    cubbyhole    cubbyhole_9cc57bcf    per-token private secret storage
identity/     identity     identity_41faabef     identity store
secret/       kv           kv_fca914b5           key/value secret storage
sys/          system       system_5dd83198       system endpoints used for control, policy and debugging
</code></pre><p>你可以檢查目前環境變數中，與 Vault 有關的 env</p><pre><code class=language-bash>env | grep VAULT
</code></pre><p>output</p><pre><code class=language-bash>VAULT_ADDR=http://127.0.0.1:8200
VAULT_TOKEN=hvs.qCqY...p89KYv
</code></pre><p>當然，<code>VAULT_TOKEN</code> 的存在時間越久，token 曝險的機率就越高。</p><p>也很容易忘記 <code>VAULT_TOKEN</code> 有存在的環境變數。</p><h3 id=vault-token-雷點>VAULT TOKEN 雷點<a hidden class=anchor aria-hidden=true href=#vault-token-雷點>#</a></h3><p>workshop 至今，你目前只有一台 vault dev server，而且裡面並沒有任何的機密資料，這個 vault server 可以隨時拋棄。</p><p>然而，在實務上，Vault 管理員手上可能會有多個 Vault server 需要管理。</p><p>想像你有 dev / stag / prod 的 server，某一天你正在 dev 開發一個新功能，由於本地有 <code>VAULT_TOKEN</code> 與 <code>VAULT_ADDR</code>，你不疑有他的在這台 server 上運行許多測試的指令，包含新增一對測試 secret，刪刪改改現有的 secret。</p><p>然後你的本能忽然覺得怪怪的，我沒有設置任何 vault env，為何可以直接存取 dev server？</p><p>你拉出 env 看，發現是 production server 的 addr + token，上次進入 production server 時的 session，還存有有效的 addr 與 token</p><pre><code class=language-bash>VAULT_ADDR=http://vault.prod.chechia.net
VAULT_TOKEN=this-is-prod-token
</code></pre><p>你麻煩大了</p><p>心得：永遠不要儲存長效期的 token 在本地。本 workshop 會不斷地強調，提醒各種操作中的資安風險，請各位學習過程中就養成良好習慣，以免方便一時，遺憾終身。</p><h3 id=root-token>root token<a hidden class=anchor aria-hidden=true href=#root-token>#</a></h3><p><a href=https://developer.hashicorp.com/vault/docs/concepts/tokens#root-tokens>https://developer.hashicorp.com/vault/docs/concepts/tokens#root-tokens</a></p><p>root token是附帶root policy的token。root token可以在Vault中執行任何操作。任何操作。</p><p>此外，它們是Vault中唯一可以設置為永不過期，且無需進行任何續訂的 token 類型。由於 root token 權限如此大，Vault 設計上刻意讓創建root token 很困難；實際上只有三種方法可以創建root token：</p><ol><li><p>在 vault operator init 時生成的初始root token - 此token不會過期</p></li><li><p>使用另一個root token 創建 root token。這點有個限制：使用有限期的root token，無法創建永不過期的root token</p></li><li><p>在擁有 unseal keys quorum的權限下，使用 vault operator generate-root 來創建root token</p></li></ol><p>root token在開發中很有用，但在 production 環境中應該非常謹慎使用。</p><p>事實上，Vault團隊建議 root token 只能進行必要的初始設置，通常是設置身份驗證方法(auth method)，和必要的 policy，以允許管理員獲取更有限的token。或是緊急情況下使用root token，並在不再需要時立即撤銷(revoke)。</p><p>如果需要新的root token，可以使用 operator generate-root 指令，使用相關的 API endpoint即時生成。</p><p>同時，當root token處於活動狀態時，建議團隊中提供多人一起協作，共同檢查 terminal session，養成一種良好的安全實踐。這樣多人可以驗證使用root token執行的任務，以及這些任務完成後，立即撤銷了該token。</p><h3 id=使用-root-token-產生-short-live-token>使用 root token 產生 short-live token<a hidden class=anchor aria-hidden=true href=#使用-root-token-產生-short-live-token>#</a></h3><p>root token 預設配置 root policy，我們可以產生權限較小的 token，並指配置最小必要權限(least privilege)</p><pre><code>VAULT_TOKEN=hvs.qCqY...p89KYv vault token create

Key                  Value
---                  -----
token                hvs.FbAeX...kjBIp
token_accessor       rPOOSI06WGnFo9MVOvS8luhn
token_duration       ∞
token_renewable      false
token_policies       [&quot;root&quot;]
identity_policies    []
policies             [&quot;root&quot;]
</code></pre><p>已創建token，輸出中以key value的表格描述了此token。創建的token在此處顯示為 hvs.FbAeX&mldr;kjBIp</p><p>此token是root token的子token，並且預設情況下，它會繼承其 parent token的policy 權限。</p><p>token是核心身份驗證方法(core auth method)。你可以使用生成的token來 login Vault，只需在提示時複製並粘貼即可。</p><p>你可以使用以下指令登入 vault</p><pre><code class=language-bash>vault login
</code></pre><p>在回傳的輸入令中輸入新產生的 child token hvs.FbAeX&mldr;kjBIp</p><pre><code class=language-bash>
WARNING! The VAULT_TOKEN environment variable is set! The value of this
variable will take precedence; if this is unwanted please unset VAULT_TOKEN or
update its value accordingly.

# 警告！已設置 VAULT_TOKEN 環境變數！此變數的值將優先考慮；如果不需要此設置，請取消設置 VAULT TOKEN 或相應地更新其值。
</code></pre><p>由於在前面的操作中，環境變數中仍帶有 <code>VAULT_TOKEN</code>，而且是更高權限的永不過期 root token，vault CLI 偵測到 VAULT TOKEN env，跳出警告。</p><p>你可以透過以下指令清除 <code>VAULT_TOKEN</code> 環境變數</p><pre><code class=language-bash>unset VAULT_TOKEN
</code></pre><p>然後再次執行 vault login，在回傳的輸入令中輸入新產生的 child token hvs.FbAeX&mldr;kjBIp</p><pre><code class=language-bash>vault login
</code></pre><p>output，顯示成功登入，並回傳 token 的相關訊息</p><pre><code>Token (will be hidden):

Success! You are now authenticated. The token information displayed below
is already stored in the token helper. You do NOT need to run &quot;vault login&quot;
again. Future Vault requests will automatically use this token.

Key                  Value
---                  -----
token                hvs.FbAeX...kjBIp
token_accessor       rPOOSI06WGnFo9MVOvS8luhn
token_duration       ∞
token_renewable      false
token_policies       [&quot;root&quot;]
identity_policies    []
policies             [&quot;root&quot;]
</code></pre><p>此token是root token的子token，繼承其 parent token的policy 權限，也就是 root。本身是無效期限制的永久 root token。</p><p>在創建一把 token，此時由於 vault login，進入登入狀態，token 已經存在本地中</p><pre><code class=language-bash>vault token create
</code></pre><p>output，第二隻 token 為 hvs.FDjvyRFXo&mldr;QVFG。每一隻 token 都是不重複的。</p><pre><code>Key                  Value
---                  -----
token                hvs.FDjvyRFXo...QVFG
token_accessor       gLe7IrUMUq4eb2pZWVdUhbHv
token_duration       ∞
token_renewable      false
token_policies       [&quot;root&quot;]
identity_policies    []
policies             [&quot;root&quot;]
</code></pre><h3 id=revoke-撤銷-token>revoke 撤銷 token<a hidden class=anchor aria-hidden=true href=#revoke-撤銷-token>#</a></h3><p>當我們不再需要使用 token 時，最好盡快撤銷 revoke token</p><p>目前的 token 樹狀結構</p><p>初始 root token (啟動 dev Server 時預設產生的)</p><ul><li>child: hvs.FbAeX&mldr;kjBIp<ul><li>grandchild: hvs.FDjvyRFXo&mldr;QVFG</li></ul></li></ul><p>你可以使用指令，撤銷第一把產生的 token (child)</p><pre><code class=language-bash>vault token revoke hvs.FbAeX...kjBIp
</code></pre><p>CLI output，顯示 token 已經撤銷</p><pre><code class=language-bash>Success! Revoked token (if it existed)
</code></pre><p>同時，vault server log 紀錄 revoked lease</p><pre><code class=language-bash>2023-09-16T21:29:21.464+0800 [INFO]  expiration: revoked lease: lease_id=auth/token/create/hf153f5e80ed722f6816f592032a43906a5606a889bab4c13ff3368c9a1b95b69
</code></pre><p>還記得我們是使用地一把產生的 token (child) login 的嗎？目前的登入當然也隨著 token 失效，嘗試存取回傳 403 權限被拒</p><pre><code>vault secrets list

Error listing secrets engines: Error making API request.

URL: GET http://127.0.0.1:8200/v1/sys/mounts
Code: 403. Errors:

* permission denied
</code></pre><p>嘗試重新 login，使用地一把產生的 token (child) 一樣被拒</p><pre><code class=language-bash>vault login
</code></pre><p>output</p><pre><code>Token (will be hidden):
Error authenticating: error looking up token: Error making API request.

URL: GET http://127.0.0.1:8200/v1/auth/token/lookup-self
Code: 403. Errors:

* permission denied
</code></pre><p>撤銷token 時，也會一併撤銷使用這把 token 產生的子 token (grandchild)</p><p>嘗試重新 login，使用第二把產生的 token (grandchild) 一樣被拒</p><pre><code class=language-bash>vault login
</code></pre><p>output</p><pre><code>Token (will be hidden):
Error authenticating: error looking up token: Error making API request.

URL: GET http://127.0.0.1:8200/v1/auth/token/lookup-self
Code: 403. Errors:

* permission denied
</code></pre><h3 id=為何總是要使用-root-token>為何總是要使用 root token<a hidden class=anchor aria-hidden=true href=#為何總是要使用-root-token>#</a></h3><p>上面講了 vault 核心的 token auth method，相信讀者一定有一個奇怪的感覺</p><ul><li>最開始 login 需要 token</li><li>產生 token 在去產生新的 token</li></ul><p>這樣產生 token 的 admin 不就需要將 token 先傳給使用者，使用者才能登入嗎？這樣傳遞 token 的行為，不是反而增加更大的曝險。</p><p>這樣真的有比一般使用 username password 登入的方法更安全嗎？</p><p>上面的想法都是有道理的，也就是說，光使用 token auth methods 是無法滿足我們的安全需求。這些安全需求，需要使用其他 auth method 方法來解決，而 vault 強大之處便是支援的許多 auth method，將 vault 的安全建立在其他更穩定的服務上，例如 github / aws / azure / gcp / kubernetes 等。</p><p>下一篇，我們就來實作 github auth method。</p><h3 id=chatgpt>chatGPT<a hidden class=anchor aria-hidden=true href=#chatgpt>#</a></h3><p>本段部分內容使用 chatGPT-3.5 翻譯
<a href=https://developer.hashicorp.com/vault/tutorials/getting-started/getting-started-authentication>https://developer.hashicorp.com/vault/tutorials/getting-started/getting-started-authentication</a>
內容，並由筆者人工校驗</p><p>base context</p><pre><code>我希望你能充當一名繁體中文翻譯，拼寫修正者和改進者。我將用英文與程式語言與你對話，你將翻譯它，並以已糾正且改進的版本回答，以繁體中文表達。我希望你能用更美麗和優雅、高級的繁體中文詞語和句子替換我簡化的詞語和句子。保持意義不變。我只希望你回答糾正和改進，不要寫解釋。

不要使用敬語，翻譯結果中若出現&quot;您&quot;，請用&quot;你&quot;取代&quot;您&quot;。
</code></pre><p>result correction</p><pre><code>部分英文內容為專有名詞，產生的繁體中文翻譯結果中，這些名詞維持英文，不需要翻譯成中文：key，value，certificate，token，policy，policy rule，path，path-based，key rolling，audit，audit trail，plain text，key value，Consul，S3 bucket，Leasing，Renewal，binary，prefix，instance，metadata。

修正下列翻譯：將 &quot;數據&quot; 改為 &quot;資料&quot;，將 &quot;數據庫&quot; 改為 &quot;資料庫&quot;，將 &quot;數據&quot; 改為 &quot;資料&quot;，將 &quot;訪問&quot; 改為 &quot;存取&quot;，將 &quot;源代碼&quot; 改為 &quot;原始碼&quot;，將 &quot;信息&quot; 改為 &quot;資訊&quot;，將 &quot;命令&quot; 改為 &quot;指令&quot;，將 &quot;禁用&quot; 改為 &quot;停用&quot;，將 &quot;默認&quot; 改為 &quot;預設&quot;。
</code></pre></div><footer class=post-footer><ul class=post-tags><li><a href=https://chechia.net/tags/vault/>Vault</a></li><li><a href=https://chechia.net/tags/iac/>Iac</a></li><li><a href=https://chechia.net/tags/workshop/>Workshop</a></li><li><a href=https://chechia.net/tags/terraform/>Terraform</a></li><li><a href=https://chechia.net/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD2023/>鐵人賽2023</a></li><li><a href=https://chechia.net/tags/chatgpt/>Chatgpt</a></li></ul><nav class=paginav><a class=prev href=https://chechia.net/posts/2023-09-17-vault-workshop-authentication-github/><span class=title>« Prev</span><br><span>Vault Workshop 06: Github Auth method</span>
</a><a class=next href=https://chechia.net/posts/2023-09-15-vault-workshop-secret-engine-kv-v2/><span class=title>Next »</span><br><span>Vault Workshop 04: Secret Engine KV V2</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Vault Workshop 05: Authentication on x" href="https://x.com/intent/tweet/?text=Vault%20Workshop%2005%3a%20Authentication&amp;url=https%3a%2f%2fchechia.net%2fposts%2f2023-09-16-vault-workshop-authentication%2f&amp;hashtags=vault%2ciac%2cworkshop%2cterraform%2c%e9%90%b5%e4%ba%ba%e8%b3%bd2023%2cchatgpt"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Vault Workshop 05: Authentication on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fchechia.net%2fposts%2f2023-09-16-vault-workshop-authentication%2f&amp;title=Vault%20Workshop%2005%3a%20Authentication&amp;summary=Vault%20Workshop%2005%3a%20Authentication&amp;source=https%3a%2f%2fchechia.net%2fposts%2f2023-09-16-vault-workshop-authentication%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Vault Workshop 05: Authentication on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fchechia.net%2fposts%2f2023-09-16-vault-workshop-authentication%2f&title=Vault%20Workshop%2005%3a%20Authentication"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Vault Workshop 05: Authentication on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fchechia.net%2fposts%2f2023-09-16-vault-workshop-authentication%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Vault Workshop 05: Authentication on whatsapp" href="https://api.whatsapp.com/send?text=Vault%20Workshop%2005%3a%20Authentication%20-%20https%3a%2f%2fchechia.net%2fposts%2f2023-09-16-vault-workshop-authentication%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Vault Workshop 05: Authentication on telegram" href="https://telegram.me/share/url?text=Vault%20Workshop%2005%3a%20Authentication&amp;url=https%3a%2f%2fchechia.net%2fposts%2f2023-09-16-vault-workshop-authentication%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Vault Workshop 05: Authentication on ycombinator" href="https://news.ycombinator.com/submitlink?t=Vault%20Workshop%2005%3a%20Authentication&u=https%3a%2f%2fchechia.net%2fposts%2f2023-09-16-vault-workshop-authentication%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://chechia.net/>Che-Chia Chang</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>