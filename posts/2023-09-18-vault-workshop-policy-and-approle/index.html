<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Vault Workshop 07: Policy & approle | Che-Chia Chang</title><meta name=keywords content="vault,iac,workshop,terraform,鐵人賽2023,chatgpt"><meta name=description content='如果你希望追蹤最新的草稿，請見鐵人賽2023
本 workshop 也接受網友的許願清單，如果有興趣的題目可於第一篇底下留言，筆者會盡力實現，但不做任何保證
整篇 Workshop 會使用的範例與原始碼，放在 Github Repository: vault-playground
Day 07: Policy & Approle
在 Vault 中，策略（Policies）控制著使用者可以訪問的資源。在上一篇身份驗證中，你已經學到了身份驗證方法(authentication method)。而這一節是關於授權(Authorization)，也就是合法的用戶登入後，應該能夠取得怎樣的權限。
在身份驗證方面，Vault 提供了多種啟用和使用的選項或方法。Vault 在授權和 policy 方面也使用相同的設計。所有身份驗證方法都將登入者的身份 map 回與 Vault 配置的核心 policy。
準備環境
在 vault 官方網站文件中，Hashicorp 官方準備了 https://instruqt.com/的 session lab
筆者個人覺得 interactive lab 的 browser tab 很難用，也不喜歡 Terminal session 連 remote VM 的延遲，以下內容還是會使用 local dev Server 說明。
觀眾們可以自己斟酌使用。
Policy 格式
策略（Policies）是以HCL撰寫的，但也兼容JSON格式。以下是一個範例策略：
# Dev servers have version 2 of KV secrets engine mounted by default, so will
# need these paths to grant permissions:
path "secret/data/*" {
  capabilities = ["create", "update"]
}

path "secret/data/foo" {
  capabilities = ["read"]
}

這個範例 policy 授予了對 KV v2 秘密管理（secrets engine）的資源的能力。如果你對於與這個秘密管理引擎相關的路徑不熟悉，可以查閱該秘密管理引擎文件中的 ACL 規則部分。'><meta name=author content="chechiachang"><link rel=canonical href=https://chechia.net/posts/2023-09-18-vault-workshop-policy-and-approle/><meta name=google-site-verification content="G-QYR8JCDGM9"><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://chechia.net/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://chechia.net/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://chechia.net/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://chechia.net/favicon/favicon-32x32.png><link rel=mask-icon href=https://chechia.net/favicon/favicon-32x32.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://chechia.net/posts/2023-09-18-vault-workshop-policy-and-approle/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-QYR8JCDGM9"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-QYR8JCDGM9")}</script><meta property="og:url" content="https://chechia.net/posts/2023-09-18-vault-workshop-policy-and-approle/"><meta property="og:site_name" content="Che-Chia Chang"><meta property="og:title" content="Vault Workshop 07: Policy & approle"><meta property="og:description" content='如果你希望追蹤最新的草稿，請見鐵人賽2023
本 workshop 也接受網友的許願清單，如果有興趣的題目可於第一篇底下留言，筆者會盡力實現，但不做任何保證
整篇 Workshop 會使用的範例與原始碼，放在 Github Repository: vault-playground
Day 07: Policy & Approle 在 Vault 中，策略（Policies）控制著使用者可以訪問的資源。在上一篇身份驗證中，你已經學到了身份驗證方法(authentication method)。而這一節是關於授權(Authorization)，也就是合法的用戶登入後，應該能夠取得怎樣的權限。
在身份驗證方面，Vault 提供了多種啟用和使用的選項或方法。Vault 在授權和 policy 方面也使用相同的設計。所有身份驗證方法都將登入者的身份 map 回與 Vault 配置的核心 policy。
準備環境 在 vault 官方網站文件中，Hashicorp 官方準備了 https://instruqt.com/的 session lab
筆者個人覺得 interactive lab 的 browser tab 很難用，也不喜歡 Terminal session 連 remote VM 的延遲，以下內容還是會使用 local dev Server 說明。
觀眾們可以自己斟酌使用。
Policy 格式 策略（Policies）是以HCL撰寫的，但也兼容JSON格式。以下是一個範例策略：
# Dev servers have version 2 of KV secrets engine mounted by default, so will # need these paths to grant permissions: path "secret/data/*" { capabilities = ["create", "update"] } path "secret/data/foo" { capabilities = ["read"] } 這個範例 policy 授予了對 KV v2 秘密管理（secrets engine）的資源的能力。如果你對於與這個秘密管理引擎相關的路徑不熟悉，可以查閱該秘密管理引擎文件中的 ACL 規則部分。'><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-09-14T03:42:26+08:00"><meta property="article:modified_time" content="2023-09-14T03:42:26+08:00"><meta property="article:tag" content="Vault"><meta property="article:tag" content="Iac"><meta property="article:tag" content="Workshop"><meta property="article:tag" content="Terraform"><meta property="article:tag" content="鐵人賽2023"><meta property="article:tag" content="Chatgpt"><meta property="og:image" content="https://chechia.net/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://chechia.net/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Vault Workshop 07: Policy & approle"><meta name=twitter:description content='如果你希望追蹤最新的草稿，請見鐵人賽2023
本 workshop 也接受網友的許願清單，如果有興趣的題目可於第一篇底下留言，筆者會盡力實現，但不做任何保證
整篇 Workshop 會使用的範例與原始碼，放在 Github Repository: vault-playground
Day 07: Policy & Approle
在 Vault 中，策略（Policies）控制著使用者可以訪問的資源。在上一篇身份驗證中，你已經學到了身份驗證方法(authentication method)。而這一節是關於授權(Authorization)，也就是合法的用戶登入後，應該能夠取得怎樣的權限。
在身份驗證方面，Vault 提供了多種啟用和使用的選項或方法。Vault 在授權和 policy 方面也使用相同的設計。所有身份驗證方法都將登入者的身份 map 回與 Vault 配置的核心 policy。
準備環境
在 vault 官方網站文件中，Hashicorp 官方準備了 https://instruqt.com/的 session lab
筆者個人覺得 interactive lab 的 browser tab 很難用，也不喜歡 Terminal session 連 remote VM 的延遲，以下內容還是會使用 local dev Server 說明。
觀眾們可以自己斟酌使用。
Policy 格式
策略（Policies）是以HCL撰寫的，但也兼容JSON格式。以下是一個範例策略：
# Dev servers have version 2 of KV secrets engine mounted by default, so will
# need these paths to grant permissions:
path "secret/data/*" {
  capabilities = ["create", "update"]
}

path "secret/data/foo" {
  capabilities = ["read"]
}

這個範例 policy 授予了對 KV v2 秘密管理（secrets engine）的資源的能力。如果你對於與這個秘密管理引擎相關的路徑不熟悉，可以查閱該秘密管理引擎文件中的 ACL 規則部分。'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://chechia.net/posts/"},{"@type":"ListItem","position":2,"name":"Vault Workshop 07: Policy \u0026 approle","item":"https://chechia.net/posts/2023-09-18-vault-workshop-policy-and-approle/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Vault Workshop 07: Policy \u0026 approle","name":"Vault Workshop 07: Policy \u0026 approle","description":"如果你希望追蹤最新的草稿，請見鐵人賽2023\n本 workshop 也接受網友的許願清單，如果有興趣的題目可於第一篇底下留言，筆者會盡力實現，但不做任何保證\n整篇 Workshop 會使用的範例與原始碼，放在 Github Repository: vault-playground\nDay 07: Policy \u0026amp; Approle 在 Vault 中，策略（Policies）控制著使用者可以訪問的資源。在上一篇身份驗證中，你已經學到了身份驗證方法(authentication method)。而這一節是關於授權(Authorization)，也就是合法的用戶登入後，應該能夠取得怎樣的權限。\n在身份驗證方面，Vault 提供了多種啟用和使用的選項或方法。Vault 在授權和 policy 方面也使用相同的設計。所有身份驗證方法都將登入者的身份 map 回與 Vault 配置的核心 policy。\n準備環境 在 vault 官方網站文件中，Hashicorp 官方準備了 https://instruqt.com/的 session lab\n筆者個人覺得 interactive lab 的 browser tab 很難用，也不喜歡 Terminal session 連 remote VM 的延遲，以下內容還是會使用 local dev Server 說明。\n觀眾們可以自己斟酌使用。\nPolicy 格式 策略（Policies）是以HCL撰寫的，但也兼容JSON格式。以下是一個範例策略：\n# Dev servers have version 2 of KV secrets engine mounted by default, so will # need these paths to grant permissions: path \u0026quot;secret/data/*\u0026quot; { capabilities = [\u0026quot;create\u0026quot;, \u0026quot;update\u0026quot;] } path \u0026quot;secret/data/foo\u0026quot; { capabilities = [\u0026quot;read\u0026quot;] } 這個範例 policy 授予了對 KV v2 秘密管理（secrets engine）的資源的能力。如果你對於與這個秘密管理引擎相關的路徑不熟悉，可以查閱該秘密管理引擎文件中的 ACL 規則部分。\n","keywords":["vault","iac","workshop","terraform","鐵人賽2023","chatgpt"],"articleBody":"如果你希望追蹤最新的草稿，請見鐵人賽2023\n本 workshop 也接受網友的許願清單，如果有興趣的題目可於第一篇底下留言，筆者會盡力實現，但不做任何保證\n整篇 Workshop 會使用的範例與原始碼，放在 Github Repository: vault-playground\nDay 07: Policy \u0026 Approle 在 Vault 中，策略（Policies）控制著使用者可以訪問的資源。在上一篇身份驗證中，你已經學到了身份驗證方法(authentication method)。而這一節是關於授權(Authorization)，也就是合法的用戶登入後，應該能夠取得怎樣的權限。\n在身份驗證方面，Vault 提供了多種啟用和使用的選項或方法。Vault 在授權和 policy 方面也使用相同的設計。所有身份驗證方法都將登入者的身份 map 回與 Vault 配置的核心 policy。\n準備環境 在 vault 官方網站文件中，Hashicorp 官方準備了 https://instruqt.com/的 session lab\n筆者個人覺得 interactive lab 的 browser tab 很難用，也不喜歡 Terminal session 連 remote VM 的延遲，以下內容還是會使用 local dev Server 說明。\n觀眾們可以自己斟酌使用。\nPolicy 格式 策略（Policies）是以HCL撰寫的，但也兼容JSON格式。以下是一個範例策略：\n# Dev servers have version 2 of KV secrets engine mounted by default, so will # need these paths to grant permissions: path \"secret/data/*\" { capabilities = [\"create\", \"update\"] } path \"secret/data/foo\" { capabilities = [\"read\"] } 這個範例 policy 授予了對 KV v2 秘密管理（secrets engine）的資源的能力。如果你對於與這個秘密管理引擎相關的路徑不熟悉，可以查閱該秘密管理引擎文件中的 ACL 規則部分。\n根據這個 policy，使用者可以對 secret/data/ 中的任何秘密進行寫入操作，但對於 secret/data/foo 的存取僅允許讀取。policy 的預設行為是 Deny，因此不允許對未指定路徑的資源進行任何存取。\npolicy 格式使用 prefix 匹配系統來確定對 API 路徑的訪問控制。使用最具體的已定義策略，即精確匹配或最長 prefix 匹配。也就是存取 secret/data/foo 路徑符合上面兩條規則，但是由於第二條規則的路徑 match 最長最精確，所以最終拿到的權限是 “read”\n由於 Vault 中的一切都必須通過 API 進行訪問，這使得對 Vault 的每個方面都有嚴格的控制，包括啟用秘密管理引擎、啟用身份驗證方法、身份驗證，以及存取秘密等。\n有一些內建的策略無法被移除。例如，root policy 和 default policy 是必需的策略，無法被刪除。\ndefault policy 提供了一組常見的權限，並且 default 包含在所有 token 中。 root policy 給予 token 超級管理員權限，類似於Linux機器上的 root 用戶。 啟動本地開發環境 步驟在前幾篇已經出現過數次，這邊就簡單帶過\nvault server -dev -dev-no-store-token export VAULT_ADDR='http://127.0.0.1:8200' unset VAULT_TOKEN vault login Defult policy 你可以用下列指令列出預設的 policy\nvault policy list output\ndefault root 可以用以下指令讀取 default policy 的內容\nvault policy read default output 回傳許多條 policy rule，主要是給予 token 基本的操作權限\n# Allow tokens to look up their own properties path \"auth/token/lookup-self\" { capabilities = [\"read\"] } # Allow tokens to renew themselves path \"auth/token/renew-self\" { capabilities = [\"update\"] } # Allow tokens to revoke themselves path \"auth/token/revoke-self\" { capabilities = [\"update\"] } ... 熟悉 default policy 內容後，可以斟酌使用。或是選擇從頭編寫自己的 policy。\n編寫第一個 policy 要撰寫 policy ，使用 vault policy write 指令。請查閱該指令的幫助文件以進一步了解用法。\nvault policy write -h Usage: vault policy write [options] NAME PATH Uploads a policy with name NAME from the contents of a local file PATH or stdin. If PATH is \"-\", the policy is read from stdin. Otherwise, it is loaded from the file at the given path on the local disk. # 使用 vault policy write 指令，可以從本地文件 PATH 或標準輸入（stdin）的內容上傳一個名為 NAME 的策略。如果 PATH 是 \"-\"，則策略將從 stdin 讀取。否則，它將從本地 disk 上給定路徑的文件中載入。 Upload a policy named \"my-policy\" from \"/tmp/policy.hcl\" on the local disk: $ vault policy write my-policy /tmp/policy.hcl Upload a policy from stdin: $ cat my-policy.hcl | vault policy write my-policy - 使用以下指令創建名為 “my-policy” 的 policy，並將其內容來自 stdin（標準輸入）\nvault policy write my-policy - \u003c\u003c EOF # Dev servers have version 2 of KV secrets engine mounted by default, so will # need these paths to grant permissions: path \"secret/data/*\" { capabilities = [\"create\", \"update\"] } path \"secret/data/foo\" { capabilities = [\"read\"] } EOF output\nSuccess! Uploaded policy: my-policy 使用下列指令列出 policy\nvault policy list output\ndefault my-policy root 讀取 my-policy 的內容\nvault policy read my-policy output\n# Dev servers have version 2 of KV secrets engine mounted by default, so will # need these paths to grant permissions: path \"secret/data/*\" { capabilities = [\"create\", \"update\"] } path \"secret/data/foo\" { capabilities = [\"read\"] } 測試 policy 你所建立的 policy ，提供對 KV-V2 秘密引擎所定義的秘密進行管理。policy 被附加到 Vault 直接生成的 otoken，或透過其各種授權方法生成的 token 上。\n創建一個 token ，添加 my-policy。-field flag 設定只回傳部分 key-vault data，而不是傳整個 metadata table。-policy 設定連結 token 的 policy。\nvault token create -field token -policy=my-policy hvs.CAESIIDh...UxbUU 為了簡化，本內容使用 dev 模式伺服器，直接從 token 授權方法創建 token 。請記住，在大多數 production 環境部署中，token 將由已啟用的授權方法(ex. github auth method)創建。\n可以使用 token login\nvault login output 回傳登入資訊，以及連結 token 的 policy，policy 包含 default 與 my-policy\nSuccess! You are now authenticated. The token information displayed below is already stored in the token helper. You do NOT need to run \"vault login\" again. Future Vault requests will automatically use this token. Key Value --- ----- token hvs.CAESIIDh...UxbUU token_accessor vY3aLwMSezlxeOn7YwcjxuhZ token_duration 767h56m52s token_renewable true token_policies [\"default\" \"my-policy\"] identity_policies [] policies [\"default\" \"my-policy\"] 你可以執行 vault token lookup，查找目前 token 的完整資訊\nvault token lookup output\nKey Value --- ----- accessor vY3aLwMSezlxeOn7YwcjxuhZ creation_time 1694917062 creation_ttl 768h display_name token entity_id n/a expire_time 2023-10-19T10:17:42.723364+08:00 explicit_max_ttl 0s id hvs.CAESIIDh...UxbUU issue_time 2023-09-17T10:17:42.723365+08:00 meta num_uses 0 orphan false path auth/token/create policies [default my-policy] renewable true ttl 767h55m45s type service 這個policy 啟用了 secret/ 秘密引擎內每個路徑的創建和更新功能，除了一個例外路徑 secret/data/foo 僅允許 read。\n寫入資料到 secret/data/creds\nvault kv put -mount=secret creds password=\"my-long-password\" output 回傳成功資訊，秘密已成功創建。\n== Secret Path == secret/data/creds ======= Metadata ======= Key Value --- ----- created_time 2023-09-17T02:26:44.179748Z custom_metadata deletion_time n/a destroyed false version 1 該政策僅啟用了對 secret/data/foo 路徑的讀取功能。嘗試向此路徑寫入將導致\"權限拒絕\"錯誤。請嘗試寫入 secret/data/foo 路徑。\nvault kv put -mount=secret foo robot=beepboop output，顯示權限錯誤。\nError writing data to secret/data/foo: Error making API request. URL: PUT http://127.0.0.1:8200/v1/secret/data/foo Code: 403. Errors: * 1 error occurred: * permission denied 此 policy 定義了一組有限的路徑和功能。如果沒有對 sys 的訪問權限，則系統相關玄線，像 vault policy list 或 vault secrets list 這樣的命令將無法運作。\nkv v2 與 v1 語法 當你使用 vault kv CLI 命令訪問 KV v2 秘密引擎時，我們建議使用 -mount flag 語法，來引用 KV v2 秘密引擎的路徑。\nvault kv get -mount=secret foo\n你也可以使用兼容 KV v1 風格的路徑 prefix 語法，在某個範圍內上是等效的，系統將自動附加 /data 到秘密路徑，可能會引起混淆。\nvault kv get secret/foo\n連結 policy 與 auth method Vault 本身只有唯一的 policy 授權管理機構，不同於身份驗證，你可以啟用多個身份驗證方法。\n你可以配置身份驗證方法，以自動分配一組 policy，給使用某些身份驗證方法創建的 token 。這樣做的方式取決於相關的身份驗證方法，但通常涉及將 role 映射到 policy ，或者將 identity 或 group 映射到 policy。\n例如：當設定 github auth method 的 role 時，你可以使用 token policies 參數來實現這一點。\n我們這邊嘗試建立另外一個 auth method，AppRole，順便在整理一次 vault -\u003e auth method -\u003e policy 的關係\n配置 AppRole 身份驗證方法 在以下步驟中，使用權限更高的 root token 進行操作與登入\nvault login output\nToken (will be hidden): Success! You are now authenticated. The token information displayed below is already stored in the token helper. You do NOT need to run \"vault login\" again. Future Vault requests will automatically use this token. Key Value --- ----- token hvs.uCGr6...749AI token_accessor SlAe0epU6CLngp2iclB5WN2A token_duration ∞ token_renewable false token_policies [\"root\"] identity_policies [] policies [\"root\"] 啟用 approle auth method\nvault auth enable approle output\nSuccess! Enabled approle auth method at: approle/ vault server log\n2023-09-17T10:44:26.460+0800 [INFO] core: enabled credential backend: path=approle/ type=approle version=\"\" approle 配置 role 我們已經啟用 approle 這個 auth method，接下來要設定名為 “my-role” 的 AppRole role，配置一些基本的token 設定，並將先前定義的 “my-policy” policy，附加到所有通過該 role 創建的 token。\n你可以使用下列指令，在 auth/approle/role/ 下新增 my-role，path 也代表 approle / role / my-role 的階層關係\nvault write auth/approle/role/my-role \\ secret_id_ttl=10m \\ token_num_uses=10 \\ token_ttl=20m \\ token_max_ttl=30m \\ secret_id_num_uses=40 \\ token_policies=my-policy output\nSuccess! Data written to: auth/approle/role/my-role 你可以通過使用 auth 方法來驗證這個 AppRole role 是否附加了policy。\n要使用 AppRole 進行身份驗證，首先需要獲取角色ID\n首先先讀取目前 approle/role/my-role 的設定\nv read auth/approle/role/my-role Key Value --- ----- bind_secret_id true local_secret_ids false secret_id_bound_cidrs secret_id_num_uses 40 secret_id_ttl 10m token_bound_cidrs [] token_explicit_max_ttl 0s token_max_ttl 30m token_no_default_policy false token_num_uses 10 token_period 0s token_policies [my-policy] token_ttl 20m token_type default 然後讀取 my-role 的 role-id\nvault read auth/approle/role/my-role/role-id output\nKey Value --- ----- role_id 600dce48-244c-094e-aeae-cb819ec7f5dd 接下來，獲取一個秘密ID(它類似於應用程式用於 AppRole 身份驗證的密碼)，由於我們這個示範並不提供額外參數值，這先需要使用 -f | -force flag，強迫 vault 寫入一個沒有 value 的資料到 auth/approle/role/my-role/secret-id endpoint\nvault write -f auth/approle/role/my-role/secret-id 可以想像是向 API server 打 POST my-role/secret-id，向 approle 註冊一個 app，server 則回傳一組 id，以辨識這個 app。\nKey Value --- ----- secret_id d80db935-9792-faf7-306d-93a2f0c3a18f secret_id_accessor 32451384-f985-a387-175b-67140225856f secret_id_num_uses 40 secret_id_ttl 10m 最後進行 login 取得 token，這裡使用 vault write 進行 AppRole 身份驗證，指定 role path並使用相應的選項傳遞role id和secret id\nexport ROLE_ID=600dce48-244c-094e-aeae-cb819ec7f5dd export SECRET_ID=d80db935-9792-faf7-306d-93a2f0c3a18f vault write auth/approle/login \\ role_id=$ROLE_ID \\ secret_id=$SECRET_ID output，取得合法的 token，並且具有我們為 approle/my-role 配置的 my-policy 權限\nKey Value --- ----- token hvs.CAESIB9gD3aupV5X06IRIWMEvhL4QeBtizO20i2Hh2YderxpGh4KHGh2cy5BWVVWVDVFUVI3dkw5VUFUbmdoZmpnUFA token_accessor QGrKxnHH4e9SVLqhpaqgYsCZ token_duration 20m token_renewable true token_policies [\"default\" \"my-policy\"] identity_policies [] policies [\"default\" \"my-policy\"] token_meta_role_name my-role 實務中，這個 secret_id 會設置在 application 上，讓 application 具有合法存取 vault 的權限\n實務範例講解 我們可以重複使用設定好的 policy，綁定到 auth method 上，policy 對 auth method 是多對多的，這邊透過我們上篇 github auth method 來對照一下，解釋 auth method 與 role / policy 的關係\nchechia-net 是一個組織\nas a admin，我希望藉由 github auth method，讓有 github 權限的工程師，可以存取 vault\n並且在 github 上的 org / team 管理各個使用者，vault 可以直接複用 github 的權限階層 於是，透過 github auth method，自動配置 vault 權限給 chechia-net github org 下的使用者\nvault auth enable -path=github-chechia github vault write auth/github-chechia/config organization=chechia-net as a github user，我希望藉由 github auth method，直接登入 vault，不用註冊額外的帳號\nvault login -method=github -path=github-chechia 換成 approle 也是相同道理\nas a admin，我希望我的 application 能夠有辦法存取 vault\n可能是一個 badkend golang server，需要存取 vault 中的 mysql database credential vault auth enable -path=approle-golang-server approle 這個 application 可能有複數不同種類工作，所以也希望能夠配置不同的 role，給予不同的 policy 權限\nrole/default 有 default policy role/my-role 有 default, my-policy 兩個 policy 更接近實務的例子，底下可能是常見的 role 用途\napprole/database，當 application 需要向 db 存取時使用，ex. 去取得 mysql 相關的 credential approle/frontend，讓 application 可以向前端存取測試需要 credential approle/qa，也許是 application 自動化測試的 credential 想表達，雖然來源都是相同 application，使用 approle auth method，vault 還是可以設定不同的 policy，讓 application 取用最小的可用權限，而不會每次登入 vault 都是很大的權限 身為 admin，你可以使用以下命令，在 approle-golang-server 中產生一個 default role\nvault write auth/approle-golang-server/role/default \\ secret_id_ttl=10m \\ token_num_uses=10 \\ token_ttl=20m \\ token_max_ttl=30m \\ secret_id_num_uses=40 \\ token_policies=default 增加一個 my-role\nvault write auth/approle-golang-server/role/my-role \\ secret_id_ttl=10m \\ token_num_uses=10 \\ token_ttl=20m \\ token_max_ttl=30m \\ secret_id_num_uses=40 \\ token_policies=default,my-policy 列出在 approle-golang-server 中啟用的 role\nvault list auth/approle-golang-server/role/ output\nKeys ---- default my-role admin 配置完 role 後，記得讀取 role-id，並將 role-id 配置到 application 上\n可以在 application 中維護一個 map，當使用這透過 application，拿到 default role，就使用 default/role-id 搭配接近實務的例子，就是如果是後端工程師使用 application，application 要能夠使用 role/backend/role-id，來向 vault 進行 authentication 你也可以讓 application 有權限讀取 auth/approle-golang-server/role/*/role-id，讓 application 透過 vault API 自動取得 role-id vault read auth/approle-golang-server/role/default/role-id vault read auth/approle-golang-server/role/my-role/role-id output\nKey Value --- ----- role_id f0340d97-a97d-85f9-30d5-65a2058baf11 Key Value --- ----- role_id c1f3cd3e-8f0a-8b1f-91f7-a3a310b9755f 上面是 admin 需要配置的內容\n現在角色換成 application，application 上線了。application 依照情境，選擇要使用那個 role，去取得 secret-id\n例如 application 要去存取 database，就自己使用 role/database 注意，這個 role/database 與 policy/database 上面都沒有配置，請讀者自己練習，配置一個 placeholder 空的權限，或是發揮創意也可以\nvault write -f auth/approle-golang-server/role/my-role/secret-id output，vault 回覆一組短時效的 secret-id，ttl=10 min\nKey Value --- ----- secret_id ad70d84b-56a5-eec2-0a95-6aa7f2cfceef secret_id_accessor 76a5b993-a139-9837-5990-b6adc483542a secret_id_num_uses 40 secret_id_ttl 10m application 可以使用 role-id + secret-id，去取得 token\nvault write auth/approle-golang-server/login \\ role_id=$ROLE_ID \\ secret_id=$SECRET_ID output\nKey Value --- ----- token hvs.CA...ZXRVc token_accessor zjBhj70A6ed72zksuooxCpYt token_duration 20m token_renewable true token_policies [\"default\" \"database\"] identity_policies [] policies [\"default\" \"database\"] token_meta_role_name database chatGPT 本段部分內容使用 chatGPT-3.5 翻譯 https://developer.hashicorp.com/vault/tutorials/getting-started/getting-started-policies https://developer.hashicorp.com/vault/docs/concepts/policies 內容，並由筆者人工校驗\nbase context\n我希望你能充當一名繁體中文翻譯，拼寫修正者和改進者。我將用英文與程式語言與你對話，你將翻譯它，並以已糾正且改進的版本回答，以繁體中文表達。我希望你能用更美麗和優雅、高級的繁體中文詞語和句子替換我簡化的詞語和句子。保持意義不變。我只希望你回答糾正和改進，不要寫解釋。 很重要：不要使用敬語，翻譯結果中若出現\"您\"，請用\"你\"取代\"您\"。 result correction\n部分英文內容為專有名詞，產生的繁體中文翻譯結果中，這些名詞維持英文，不需要翻譯成中文：key，value，certificate，token，policy，policy rule，path，path-based，key rolling，audit，audit trail，plain text，key value，Consul，S3 bucket，Leasing，Renewal，binary，prefix，instance，metadata。 修正下列翻譯：將 \"數據\" 改為 \"資料\"，將 \"數據庫\" 改為 \"資料庫\"，將 \"數據\" 改為 \"資料\"，將 \"訪問\" 改為 \"存取\"，將 \"源代碼\" 改為 \"原始碼\"，將 \"信息\" 改為 \"資訊\"，將 \"命令\" 改為 \"指令\"，將 \"禁用\" 改為 \"停用\"，將 \"默認\" 改為 \"預設\"。 ","wordCount":"1460","inLanguage":"en","image":"https://chechia.net/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2023-09-14T03:42:26+08:00","dateModified":"2023-09-14T03:42:26+08:00","author":{"@type":"Person","name":"chechiachang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://chechia.net/posts/2023-09-18-vault-workshop-policy-and-approle/"},"publisher":{"@type":"Organization","name":"Che-Chia Chang","logo":{"@type":"ImageObject","url":"https://chechia.net/favicon/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://chechia.net/ accesskey=h title="Home (Alt + H)"><img src=https://chechia.net/favicon/favicon-32x32.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://chechia.net/#posts title=Posts><span>Posts</span></a></li><li><a href=https://mvp.microsoft.com/zh-TW/mvp/profile/e407d0b9-5c01-eb11-a815-000d3a8ccaf5 title=MVP><span>MVP</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://chechia.net/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://chechia.net/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://chechia.net/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://chechia.net/>Home</a>&nbsp;»&nbsp;<a href=https://chechia.net/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Vault Workshop 07: Policy & approle</h1><div class=post-meta><span title='2023-09-14 03:42:26 +0800 CST'>September 14, 2023</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1460 words&nbsp;·&nbsp;chechiachang&nbsp;|&nbsp;<a href=https://github.com/chechiachang.github.io-src/content/posts/2023-09-18-vault-workshop-policy-and-approle/index.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><ul><li><a href=#準備環境>準備環境</a></li><li><a href=#policy-格式>Policy 格式</a></li><li><a href=#啟動本地開發環境>啟動本地開發環境</a></li><li><a href=#defult-policy>Defult policy</a></li><li><a href=#編寫第一個-policy>編寫第一個 policy</a></li><li><a href=#測試-policy>測試 policy</a></li><li><a href=#kv-v2-與-v1-語法>kv v2 與 v1 語法</a></li><li><a href=#連結-policy-與-auth-method>連結 policy 與 auth method</a></li><li><a href=#配置-approle-身份驗證方法>配置 AppRole 身份驗證方法</a></li><li><a href=#approle-配置-role>approle 配置 role</a></li><li><a href=#實務範例講解>實務範例講解</a></li><li><a href=#chatgpt>chatGPT</a></li></ul></li></ul></nav></div></details></div><div class=post-content><p>如果你希望追蹤最新的草稿，請見<a href=https://chechia.net/zh-hant/tag/%E9%90%B5%E4%BA%BA%E8%B3%BD2023/>鐵人賽2023</a></p><p>本 workshop 也接受網友的許願清單，<a href=https://ithelp.ithome.com.tw/articles/10317378>如果有興趣的題目可於第一篇底下留言</a>，筆者會盡力實現，但不做任何保證</p><p>整篇 Workshop 會使用的範例與原始碼，放在 <a href=http://chechia.net/zh-hant/#projects>Github Repository: vault-playground</a></p><h1 id=day-07-policy--approle>Day 07: Policy & Approle<a hidden class=anchor aria-hidden=true href=#day-07-policy--approle>#</a></h1><p>在 Vault 中，策略（Policies）控制著使用者可以訪問的資源。在上一篇身份驗證中，你已經學到了身份驗證方法(authentication method)。而這一節是關於授權(Authorization)，也就是合法的用戶登入後，應該能夠取得怎樣的權限。</p><p>在身份驗證方面，Vault 提供了多種啟用和使用的選項或方法。Vault 在授權和 policy 方面也使用相同的設計。所有身份驗證方法都將登入者的身份 map 回與 Vault 配置的核心 policy。</p><h3 id=準備環境>準備環境<a hidden class=anchor aria-hidden=true href=#準備環境>#</a></h3><p>在 <a href=https://developer.hashicorp.com/vault/tutorials/getting-started/getting-started-policies>vault 官方網站文件</a>中，Hashicorp 官方準備了 <a href=https://instruqt.com/>https://instruqt.com/</a>的 session lab</p><p>筆者個人覺得 interactive lab 的 browser tab 很難用，也不喜歡 Terminal session 連 remote VM 的延遲，以下內容還是會使用 local dev Server 說明。</p><p>觀眾們可以自己斟酌使用。</p><h3 id=policy-格式>Policy 格式<a hidden class=anchor aria-hidden=true href=#policy-格式>#</a></h3><p>策略（Policies）是以HCL撰寫的，但也兼容JSON格式。以下是一個範例策略：</p><pre><code class=language-hcl># Dev servers have version 2 of KV secrets engine mounted by default, so will
# need these paths to grant permissions:
path &quot;secret/data/*&quot; {
  capabilities = [&quot;create&quot;, &quot;update&quot;]
}

path &quot;secret/data/foo&quot; {
  capabilities = [&quot;read&quot;]
}
</code></pre><p>這個範例 policy 授予了對 KV v2 秘密管理（secrets engine）的資源的能力。如果你對於與這個秘密管理引擎相關的路徑不熟悉，可以查閱該秘密管理引擎文件中的 <a href=https://developer.hashicorp.com/vault/docs/secrets/kv/kv-v2#acl-rules>ACL 規則</a>部分。</p><p>根據這個 policy，使用者可以對 <code>secret/data/</code> 中的任何秘密進行寫入操作，但對於 <code>secret/data/foo</code> 的存取僅允許讀取。policy 的預設行為是 Deny，因此不允許對未指定路徑的資源進行任何存取。</p><p>policy 格式使用 prefix 匹配系統來確定對 API 路徑的訪問控制。使用最具體的已定義策略，即精確匹配或最長 prefix 匹配。也就是存取 <code>secret/data/foo</code> 路徑符合上面兩條規則，但是由於第二條規則的路徑 match 最長最精確，所以最終拿到的權限是 &ldquo;read&rdquo;</p><p>由於 Vault 中的一切都必須通過 API 進行訪問，這使得對 Vault 的每個方面都有嚴格的控制，包括啟用秘密管理引擎、啟用身份驗證方法、身份驗證，以及存取秘密等。</p><p>有一些內建的策略無法被移除。例如，root policy 和 default policy 是必需的策略，無法被刪除。</p><ul><li>default policy 提供了一組常見的權限，並且 default 包含在所有 token 中。</li><li>root policy 給予 token 超級管理員權限，類似於Linux機器上的 root 用戶。</li></ul><h3 id=啟動本地開發環境>啟動本地開發環境<a hidden class=anchor aria-hidden=true href=#啟動本地開發環境>#</a></h3><p>步驟在前幾篇已經出現過數次，這邊就簡單帶過</p><pre><code class=language-bash>vault server -dev -dev-no-store-token

export VAULT_ADDR='http://127.0.0.1:8200'

unset VAULT_TOKEN

vault login
</code></pre><h3 id=defult-policy>Defult policy<a hidden class=anchor aria-hidden=true href=#defult-policy>#</a></h3><p>你可以用下列指令列出預設的 policy</p><pre><code class=language-bash>vault policy list
</code></pre><p>output</p><pre><code class=language-bash>default
root
</code></pre><p>可以用以下指令讀取 default policy 的內容</p><pre><code class=language-bash>vault policy read default
</code></pre><p>output 回傳許多條 policy rule，主要是給予 token 基本的操作權限</p><pre><code class=language-bash># Allow tokens to look up their own properties
path &quot;auth/token/lookup-self&quot; {
    capabilities = [&quot;read&quot;]
}

# Allow tokens to renew themselves
path &quot;auth/token/renew-self&quot; {
    capabilities = [&quot;update&quot;]
}

# Allow tokens to revoke themselves
path &quot;auth/token/revoke-self&quot; {
    capabilities = [&quot;update&quot;]
}
...
</code></pre><p>熟悉 default policy 內容後，可以斟酌使用。或是選擇從頭編寫自己的 policy。</p><h3 id=編寫第一個-policy>編寫第一個 policy<a hidden class=anchor aria-hidden=true href=#編寫第一個-policy>#</a></h3><p>要撰寫 policy ，使用 vault policy write 指令。請查閱該指令的幫助文件以進一步了解用法。</p><pre><code class=language-bash>vault policy write -h
</code></pre><pre><code class=language-bash>Usage: vault policy write [options] NAME PATH

  Uploads a policy with name NAME from the contents of a local file PATH or
  stdin. If PATH is &quot;-&quot;, the policy is read from stdin. Otherwise, it is
  loaded from the file at the given path on the local disk.

# 使用 vault policy write 指令，可以從本地文件 PATH 或標準輸入（stdin）的內容上傳一個名為 NAME 的策略。如果 PATH 是 &quot;-&quot;，則策略將從 stdin 讀取。否則，它將從本地 disk 上給定路徑的文件中載入。

  Upload a policy named &quot;my-policy&quot; from &quot;/tmp/policy.hcl&quot; on the local disk:

      $ vault policy write my-policy /tmp/policy.hcl

  Upload a policy from stdin:

      $ cat my-policy.hcl | vault policy write my-policy -
</code></pre><p>使用以下指令創建名為 &ldquo;my-policy&rdquo; 的 policy，並將其內容來自 stdin（標準輸入）</p><pre><code class=language-bash>vault policy write my-policy - &lt;&lt; EOF

# Dev servers have version 2 of KV secrets engine mounted by default, so will
# need these paths to grant permissions:
path &quot;secret/data/*&quot; {
  capabilities = [&quot;create&quot;, &quot;update&quot;]
}

path &quot;secret/data/foo&quot; {
  capabilities = [&quot;read&quot;]
}
EOF
</code></pre><p>output</p><pre><code class=language-bash>Success! Uploaded policy: my-policy
</code></pre><p>使用下列指令列出 policy</p><pre><code class=language-bash>vault policy list
</code></pre><p>output</p><pre><code class=language-bash>default
my-policy
root
</code></pre><p>讀取 my-policy 的內容</p><pre><code class=language-bash>vault policy read my-policy
</code></pre><p>output</p><pre><code># Dev servers have version 2 of KV secrets engine mounted by default, so will
# need these paths to grant permissions:
path &quot;secret/data/*&quot; {
  capabilities = [&quot;create&quot;, &quot;update&quot;]
}

path &quot;secret/data/foo&quot; {
  capabilities = [&quot;read&quot;]
}
</code></pre><h3 id=測試-policy>測試 policy<a hidden class=anchor aria-hidden=true href=#測試-policy>#</a></h3><p>你所建立的 policy ，提供對 KV-V2 秘密引擎所定義的秘密進行管理。policy 被附加到 Vault 直接生成的 otoken，或透過其各種授權方法生成的 token 上。</p><p>創建一個 token ，添加 my-policy。-field flag 設定只回傳部分 key-vault data，而不是傳整個 metadata table。-policy 設定連結 token 的 policy。</p><pre><code class=language-bash>vault token create -field token -policy=my-policy
</code></pre><pre><code class=language-bash>hvs.CAESIIDh...UxbUU
</code></pre><p>為了簡化，本內容使用 dev 模式伺服器，直接從 token 授權方法創建 token 。請記住，在大多數 production 環境部署中，token 將由已啟用的授權方法(ex. github auth method)創建。</p><p>可以使用 token login</p><pre><code class=language-bash>vault login
</code></pre><p>output 回傳登入資訊，以及連結 token 的 policy，policy 包含 default 與 my-policy</p><pre><code>Success! You are now authenticated. The token information displayed below
is already stored in the token helper. You do NOT need to run &quot;vault login&quot;
again. Future Vault requests will automatically use this token.

Key                  Value
---                  -----
token                hvs.CAESIIDh...UxbUU
token_accessor       vY3aLwMSezlxeOn7YwcjxuhZ
token_duration       767h56m52s
token_renewable      true
token_policies       [&quot;default&quot; &quot;my-policy&quot;]
identity_policies    []
policies             [&quot;default&quot; &quot;my-policy&quot;]
</code></pre><p>你可以執行 vault token lookup，查找目前 token 的完整資訊</p><pre><code class=language-bash>vault token lookup
</code></pre><p>output</p><pre><code class=language-bash>Key                 Value
---                 -----
accessor            vY3aLwMSezlxeOn7YwcjxuhZ
creation_time       1694917062
creation_ttl        768h
display_name        token
entity_id           n/a
expire_time         2023-10-19T10:17:42.723364+08:00
explicit_max_ttl    0s
id                  hvs.CAESIIDh...UxbUU
issue_time          2023-09-17T10:17:42.723365+08:00
meta                &lt;nil&gt;
num_uses            0
orphan              false
path                auth/token/create
policies            [default my-policy]
renewable           true
ttl                 767h55m45s
type                service
</code></pre><p>這個policy 啟用了 secret/ 秘密引擎內每個路徑的創建和更新功能，除了一個例外路徑 secret/data/foo 僅允許 read。</p><p>寫入資料到 secret/data/creds</p><pre><code class=language-bash>vault kv put -mount=secret creds password=&quot;my-long-password&quot;
</code></pre><p>output 回傳成功資訊，秘密已成功創建。</p><pre><code class=language-bash>== Secret Path ==
secret/data/creds

======= Metadata =======
Key                Value
---                -----
created_time       2023-09-17T02:26:44.179748Z
custom_metadata    &lt;nil&gt;
deletion_time      n/a
destroyed          false
version            1
</code></pre><p>該政策僅啟用了對 secret/data/foo 路徑的讀取功能。嘗試向此路徑寫入將導致"權限拒絕"錯誤。請嘗試寫入 secret/data/foo 路徑。</p><pre><code class=language-bash>vault kv put -mount=secret foo robot=beepboop
</code></pre><p>output，顯示權限錯誤。</p><pre><code class=language-bash>Error writing data to secret/data/foo: Error making API request.

URL: PUT http://127.0.0.1:8200/v1/secret/data/foo
Code: 403. Errors:

* 1 error occurred:
	* permission denied
</code></pre><p>此 policy 定義了一組有限的路徑和功能。如果沒有對 sys 的訪問權限，則系統相關玄線，像 vault policy list 或 vault secrets list 這樣的命令將無法運作。</p><h3 id=kv-v2-與-v1-語法>kv v2 與 v1 語法<a hidden class=anchor aria-hidden=true href=#kv-v2-與-v1-語法>#</a></h3><p>當你使用 vault kv CLI 命令訪問 KV v2 秘密引擎時，我們建議使用 -mount flag 語法，來引用 KV v2 秘密引擎的路徑。</p><p><code>vault kv get -mount=secret foo</code></p><p>你也可以使用兼容 KV v1 風格的路徑 prefix 語法，在某個範圍內上是等效的，系統將自動附加 /data 到秘密路徑，可能會引起混淆。</p><p><code>vault kv get secret/foo</code></p><h3 id=連結-policy-與-auth-method>連結 policy 與 auth method<a hidden class=anchor aria-hidden=true href=#連結-policy-與-auth-method>#</a></h3><p>Vault 本身只有唯一的 policy 授權管理機構，不同於身份驗證，你可以啟用多個身份驗證方法。</p><p>你可以配置身份驗證方法，以自動分配一組 policy，給使用某些身份驗證方法創建的 token 。這樣做的方式取決於相關的身份驗證方法，但通常涉及將 role 映射到 policy ，或者將 identity 或 group 映射到 policy。</p><p>例如：當設定 github auth method 的 role 時，你可以使用 token policies 參數來實現這一點。</p><p>我們這邊嘗試建立另外一個 auth method，AppRole，順便在整理一次 vault -> auth method -> policy 的關係</p><h3 id=配置-approle-身份驗證方法>配置 AppRole 身份驗證方法<a hidden class=anchor aria-hidden=true href=#配置-approle-身份驗證方法>#</a></h3><p>在以下步驟中，使用權限更高的 root token 進行操作與登入</p><pre><code class=language-bash>vault login
</code></pre><p>output</p><pre><code class=language-bash>Token (will be hidden):

Success! You are now authenticated. The token information displayed below
is already stored in the token helper. You do NOT need to run &quot;vault login&quot;
again. Future Vault requests will automatically use this token.

Key                  Value
---                  -----
token                hvs.uCGr6...749AI
token_accessor       SlAe0epU6CLngp2iclB5WN2A
token_duration       ∞
token_renewable      false
token_policies       [&quot;root&quot;]
identity_policies    []
policies             [&quot;root&quot;]
</code></pre><p>啟用 approle auth method</p><pre><code class=language-bash>vault auth enable approle
</code></pre><p>output</p><pre><code class=language-bash>Success! Enabled approle auth method at: approle/
</code></pre><p>vault server log</p><pre><code class=language-bash>2023-09-17T10:44:26.460+0800 [INFO]  core: enabled credential backend: path=approle/ type=approle version=&quot;&quot;
</code></pre><h3 id=approle-配置-role>approle 配置 role<a hidden class=anchor aria-hidden=true href=#approle-配置-role>#</a></h3><p>我們已經啟用 approle 這個 auth method，接下來要設定名為 &ldquo;my-role&rdquo; 的 AppRole role，配置一些基本的token 設定，並將先前定義的 &ldquo;my-policy&rdquo; policy，附加到所有通過該 role 創建的 token。</p><p>你可以使用下列指令，在 auth/approle/role/ 下新增 my-role，path 也代表 approle / role / my-role 的階層關係</p><pre><code class=language-bash>vault write auth/approle/role/my-role \
   secret_id_ttl=10m \
   token_num_uses=10 \
   token_ttl=20m \
   token_max_ttl=30m \
   secret_id_num_uses=40 \
   token_policies=my-policy
</code></pre><p>output</p><pre><code class=language-bash>Success! Data written to: auth/approle/role/my-role
</code></pre><p>你可以通過使用 auth 方法來驗證這個 AppRole role 是否附加了policy。</p><p>要使用 AppRole 進行身份驗證，首先需要獲取角色ID</p><p>首先先讀取目前 approle/role/my-role 的設定</p><pre><code class=language-bash>v read auth/approle/role/my-role
</code></pre><pre><code class=language-bash>Key                        Value
---                        -----
bind_secret_id             true
local_secret_ids           false
secret_id_bound_cidrs      &lt;nil&gt;
secret_id_num_uses         40
secret_id_ttl              10m
token_bound_cidrs          []
token_explicit_max_ttl     0s
token_max_ttl              30m
token_no_default_policy    false
token_num_uses             10
token_period               0s
token_policies             [my-policy]
token_ttl                  20m
token_type                 default
</code></pre><p>然後讀取 my-role 的 role-id</p><pre><code class=language-bash>vault read auth/approle/role/my-role/role-id
</code></pre><p>output</p><pre><code class=language-bash>Key        Value
---        -----
role_id    600dce48-244c-094e-aeae-cb819ec7f5dd
</code></pre><p>接下來，獲取一個秘密ID(它類似於應用程式用於 AppRole 身份驗證的密碼)，由於我們這個示範並不提供額外參數值，這先需要使用 -f | -force flag，強迫 vault 寫入一個沒有 value 的資料到 auth/approle/role/my-role/secret-id endpoint</p><pre><code class=language-bash>vault write -f auth/approle/role/my-role/secret-id
</code></pre><p>可以想像是向 API server 打 POST my-role/secret-id，向 approle 註冊一個 app，server 則回傳一組 id，以辨識這個 app。</p><pre><code class=language-bash>Key                   Value
---                   -----
secret_id             d80db935-9792-faf7-306d-93a2f0c3a18f
secret_id_accessor    32451384-f985-a387-175b-67140225856f
secret_id_num_uses    40
secret_id_ttl         10m

</code></pre><p>最後進行 login 取得 token，這裡使用 vault write 進行 AppRole 身份驗證，指定 role path並使用相應的選項傳遞role id和secret id</p><pre><code class=language-bash>export ROLE_ID=600dce48-244c-094e-aeae-cb819ec7f5dd
export SECRET_ID=d80db935-9792-faf7-306d-93a2f0c3a18f

vault write auth/approle/login \
    role_id=$ROLE_ID \
    secret_id=$SECRET_ID
</code></pre><p>output，取得合法的 token，並且具有我們為 approle/my-role 配置的 my-policy 權限</p><pre><code class=language-bash>Key                     Value
---                     -----
token                   hvs.CAESIB9gD3aupV5X06IRIWMEvhL4QeBtizO20i2Hh2YderxpGh4KHGh2cy5BWVVWVDVFUVI3dkw5VUFUbmdoZmpnUFA
token_accessor          QGrKxnHH4e9SVLqhpaqgYsCZ
token_duration          20m
token_renewable         true
token_policies          [&quot;default&quot; &quot;my-policy&quot;]
identity_policies       []
policies                [&quot;default&quot; &quot;my-policy&quot;]
token_meta_role_name    my-role
</code></pre><p>實務中，這個 <code>secret_id</code> 會設置在 application 上，讓 application 具有合法存取 vault 的權限</p><h3 id=實務範例講解>實務範例講解<a hidden class=anchor aria-hidden=true href=#實務範例講解>#</a></h3><p>我們可以重複使用設定好的 policy，綁定到 auth method 上，policy 對 auth method 是多對多的，這邊透過我們上篇 github auth method 來對照一下，解釋 auth method 與 role / policy 的關係</p><p>chechia-net 是一個組織</p><p>as a admin，我希望藉由 github auth method，讓有 github 權限的工程師，可以存取 vault</p><ul><li>並且在 github 上的 org / team 管理各個使用者，vault 可以直接複用 github 的權限階層</li></ul><p>於是，透過 github auth method，自動配置 vault 權限給 chechia-net github org 下的使用者</p><pre><code class=language-bash>vault auth enable -path=github-chechia github
vault write auth/github-chechia/config organization=chechia-net
</code></pre><p>as a github user，我希望藉由 github auth method，直接登入 vault，不用註冊額外的帳號</p><pre><code class=language-bash>vault login -method=github -path=github-chechia
</code></pre><p>換成 approle 也是相同道理</p><p>as a admin，我希望我的 application 能夠有辦法存取 vault</p><ul><li>可能是一個 badkend golang server，需要存取 vault 中的 mysql database credential</li></ul><pre><code class=language-bash>vault auth enable -path=approle-golang-server approle
</code></pre><p>這個 application 可能有複數不同種類工作，所以也希望能夠配置不同的 role，給予不同的 policy 權限</p><ul><li>role/default 有 default policy</li><li>role/my-role 有 default, my-policy 兩個 policy</li></ul><p>更接近實務的例子，底下可能是常見的 role 用途</p><ul><li>approle/database，當 application 需要向 db 存取時使用，ex. 去取得 mysql 相關的 credential</li><li>approle/frontend，讓 application 可以向前端存取測試需要 credential</li><li>approle/qa，也許是 application 自動化測試的 credential
想表達，雖然來源都是相同 application，使用 approle auth method，vault 還是可以設定不同的 policy，讓 application 取用最小的可用權限，而不會每次登入 vault 都是很大的權限</li></ul><p>身為 admin，你可以使用以下命令，在 approle-golang-server 中產生一個 default role</p><pre><code class=language-bash>vault write auth/approle-golang-server/role/default \
   secret_id_ttl=10m \
   token_num_uses=10 \
   token_ttl=20m \
   token_max_ttl=30m \
   secret_id_num_uses=40 \
   token_policies=default
</code></pre><p>增加一個 my-role</p><pre><code class=language-bash>vault write auth/approle-golang-server/role/my-role \
   secret_id_ttl=10m \
   token_num_uses=10 \
   token_ttl=20m \
   token_max_ttl=30m \
   secret_id_num_uses=40 \
   token_policies=default,my-policy
</code></pre><p>列出在 approle-golang-server 中啟用的 role</p><pre><code class=language-bash>vault list auth/approle-golang-server/role/
</code></pre><p>output</p><pre><code>Keys
----
default
my-role
</code></pre><p>admin 配置完 role 後，記得讀取 role-id，並將 role-id 配置到 application 上</p><ul><li>可以在 application 中維護一個 map，當使用這透過 application，拿到 default role，就使用 default/role-id</li><li>搭配接近實務的例子，就是如果是後端工程師使用 application，application 要能夠使用 role/backend/role-id，來向 vault 進行 authentication<ul><li>你也可以讓 application 有權限讀取 <code>auth/approle-golang-server/role/*/role-id</code>，讓 application 透過 vault API 自動取得 role-id</li></ul></li></ul><pre><code class=language-bash>vault read auth/approle-golang-server/role/default/role-id
vault read auth/approle-golang-server/role/my-role/role-id
</code></pre><p>output</p><pre><code class=language-bash>Key        Value
---        -----
role_id    f0340d97-a97d-85f9-30d5-65a2058baf11

Key        Value
---        -----
role_id    c1f3cd3e-8f0a-8b1f-91f7-a3a310b9755f
</code></pre><p>上面是 admin 需要配置的內容</p><p>現在角色換成 application，application 上線了。application 依照情境，選擇要使用那個 role，去取得 secret-id</p><ul><li>例如 application 要去存取 database，就自己使用 role/database</li></ul><p>注意，這個 role/database 與 policy/database 上面都沒有配置，請讀者自己練習，配置一個 placeholder 空的權限，或是發揮創意也可以</p><pre><code class=language-bash>vault write -f auth/approle-golang-server/role/my-role/secret-id
</code></pre><p>output，vault 回覆一組短時效的 secret-id，ttl=10 min</p><pre><code class=language-bash>Key                   Value
---                   -----
secret_id             ad70d84b-56a5-eec2-0a95-6aa7f2cfceef
secret_id_accessor    76a5b993-a139-9837-5990-b6adc483542a
secret_id_num_uses    40
secret_id_ttl         10m
</code></pre><p>application 可以使用 role-id + secret-id，去取得 token</p><pre><code class=language-bash>vault write auth/approle-golang-server/login \
    role_id=$ROLE_ID \
    secret_id=$SECRET_ID
</code></pre><p>output</p><pre><code class=language-bash>Key                     Value
---                     -----
token                   hvs.CA...ZXRVc
token_accessor          zjBhj70A6ed72zksuooxCpYt
token_duration          20m
token_renewable         true
token_policies          [&quot;default&quot; &quot;database&quot;]
identity_policies       []
policies                [&quot;default&quot; &quot;database&quot;]
token_meta_role_name    database
</code></pre><h3 id=chatgpt>chatGPT<a hidden class=anchor aria-hidden=true href=#chatgpt>#</a></h3><p>本段部分內容使用 chatGPT-3.5 翻譯
<a href=https://developer.hashicorp.com/vault/tutorials/getting-started/getting-started-policies>https://developer.hashicorp.com/vault/tutorials/getting-started/getting-started-policies</a>
<a href=https://developer.hashicorp.com/vault/docs/concepts/policies>https://developer.hashicorp.com/vault/docs/concepts/policies</a>
內容，並由筆者人工校驗</p><p>base context</p><pre><code>我希望你能充當一名繁體中文翻譯，拼寫修正者和改進者。我將用英文與程式語言與你對話，你將翻譯它，並以已糾正且改進的版本回答，以繁體中文表達。我希望你能用更美麗和優雅、高級的繁體中文詞語和句子替換我簡化的詞語和句子。保持意義不變。我只希望你回答糾正和改進，不要寫解釋。

很重要：不要使用敬語，翻譯結果中若出現&quot;您&quot;，請用&quot;你&quot;取代&quot;您&quot;。
</code></pre><p>result correction</p><pre><code>部分英文內容為專有名詞，產生的繁體中文翻譯結果中，這些名詞維持英文，不需要翻譯成中文：key，value，certificate，token，policy，policy rule，path，path-based，key rolling，audit，audit trail，plain text，key value，Consul，S3 bucket，Leasing，Renewal，binary，prefix，instance，metadata。

修正下列翻譯：將 &quot;數據&quot; 改為 &quot;資料&quot;，將 &quot;數據庫&quot; 改為 &quot;資料庫&quot;，將 &quot;數據&quot; 改為 &quot;資料&quot;，將 &quot;訪問&quot; 改為 &quot;存取&quot;，將 &quot;源代碼&quot; 改為 &quot;原始碼&quot;，將 &quot;信息&quot; 改為 &quot;資訊&quot;，將 &quot;命令&quot; 改為 &quot;指令&quot;，將 &quot;禁用&quot; 改為 &quot;停用&quot;，將 &quot;默認&quot; 改為 &quot;預設&quot;。
</code></pre></div><footer class=post-footer><ul class=post-tags><li><a href=https://chechia.net/tags/vault/>Vault</a></li><li><a href=https://chechia.net/tags/iac/>Iac</a></li><li><a href=https://chechia.net/tags/workshop/>Workshop</a></li><li><a href=https://chechia.net/tags/terraform/>Terraform</a></li><li><a href=https://chechia.net/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD2023/>鐵人賽2023</a></li><li><a href=https://chechia.net/tags/chatgpt/>Chatgpt</a></li></ul><nav class=paginav><a class=prev href=https://chechia.net/posts/2023-09-19-vault-workshop-docker-and-initialization/><span class=title>« Prev</span><br><span>Vault Workshop 08: Vault in Docker and Initialization</span>
</a><a class=next href=https://chechia.net/posts/2023-09-17-vault-workshop-authentication-github/><span class=title>Next »</span><br><span>Vault Workshop 06: Github Auth method</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Vault Workshop 07: Policy & approle on x" href="https://x.com/intent/tweet/?text=Vault%20Workshop%2007%3a%20Policy%20%26%20approle&amp;url=https%3a%2f%2fchechia.net%2fposts%2f2023-09-18-vault-workshop-policy-and-approle%2f&amp;hashtags=vault%2ciac%2cworkshop%2cterraform%2c%e9%90%b5%e4%ba%ba%e8%b3%bd2023%2cchatgpt"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Vault Workshop 07: Policy & approle on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fchechia.net%2fposts%2f2023-09-18-vault-workshop-policy-and-approle%2f&amp;title=Vault%20Workshop%2007%3a%20Policy%20%26%20approle&amp;summary=Vault%20Workshop%2007%3a%20Policy%20%26%20approle&amp;source=https%3a%2f%2fchechia.net%2fposts%2f2023-09-18-vault-workshop-policy-and-approle%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Vault Workshop 07: Policy & approle on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fchechia.net%2fposts%2f2023-09-18-vault-workshop-policy-and-approle%2f&title=Vault%20Workshop%2007%3a%20Policy%20%26%20approle"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Vault Workshop 07: Policy & approle on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fchechia.net%2fposts%2f2023-09-18-vault-workshop-policy-and-approle%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Vault Workshop 07: Policy & approle on whatsapp" href="https://api.whatsapp.com/send?text=Vault%20Workshop%2007%3a%20Policy%20%26%20approle%20-%20https%3a%2f%2fchechia.net%2fposts%2f2023-09-18-vault-workshop-policy-and-approle%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Vault Workshop 07: Policy & approle on telegram" href="https://telegram.me/share/url?text=Vault%20Workshop%2007%3a%20Policy%20%26%20approle&amp;url=https%3a%2f%2fchechia.net%2fposts%2f2023-09-18-vault-workshop-policy-and-approle%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Vault Workshop 07: Policy & approle on ycombinator" href="https://news.ycombinator.com/submitlink?t=Vault%20Workshop%2007%3a%20Policy%20%26%20approle&u=https%3a%2f%2fchechia.net%2fposts%2f2023-09-18-vault-workshop-policy-and-approle%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://chechia.net/>Che-Chia Chang</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>