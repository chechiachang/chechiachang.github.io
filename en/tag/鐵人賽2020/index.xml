<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>鐵人賽2020 | Che-Chia Chang</title>
    <link>https://chechia.net/en/tag/%E9%90%B5%E4%BA%BA%E8%B3%BD2020/</link>
      <atom:link href="https://chechia.net/en/tag/%E9%90%B5%E4%BA%BA%E8%B3%BD2020/index.xml" rel="self" type="application/rss+xml" />
    <description>鐵人賽2020</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><lastBuildDate>Wed, 07 Oct 2020 11:15:48 +0800</lastBuildDate>
    <image>
      <url>https://chechia.net/media/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_3.png</url>
      <title>鐵人賽2020</title>
      <link>https://chechia.net/en/tag/%E9%90%B5%E4%BA%BA%E8%B3%BD2020/</link>
    </image>
    
    <item>
      <title>Terraform Infrastructure as Code: Atlantis</title>
      <link>https://chechia.net/en/post/2020-10-07-terraform-infrastructure-as-code-atlantis/</link>
      <pubDate>Wed, 07 Oct 2020 11:15:48 +0800</pubDate>
      <guid>https://chechia.net/en/post/2020-10-07-terraform-infrastructure-as-code-atlantis/</guid>
      <description>&lt;p&gt;This article is part of &lt;a href=&#34;https://chechia.net/en/post/2020-06-14-terraform-infrastructure-as-code/&#34;&gt;從零開始的 Infrastructu as Code: Terraform&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/chechiachang/terraform-playground&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Get-started examples / SOP on Github&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://chechia.net/en/post/2020-06-15-terraform-infrastructure-as-code-transcript/&#34;&gt;Introducation to Terraform Iac: Speaker transcript&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://slides.com/chechiachang/terraform-introduction/edit&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Presentation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Check my website &lt;a href=&#34;https://chechia.net&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;chechia.net&lt;/a&gt; for other blog. &lt;a href=&#34;https://www.facebook.com/engineer.from.scratch&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Follow my page to get notification&lt;/a&gt;. Like my page if you really like it :)&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;需求與問題&#34;&gt;需求與問題&lt;/h1&gt;
&lt;p&gt;隨著 terraform 在團隊內的規模持續成長，團隊需要讓工作流程更加順暢，來面對大量的 tf 變更查核與變更請求。想像幾十個工程師同時在修改幾十個不同的 terraform projects / modules，這時可能會有幾個問題&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要一個穩定乾淨的環境執行 terraform
&lt;ul&gt;
&lt;li&gt;工程師的開發本機不是個好選擇&lt;/li&gt;
&lt;li&gt;需要 24/7 的 terraform 執行中心
&lt;ul&gt;
&lt;li&gt;執行中心會有各個環境 (dev / stage / prod) 的存取權限，希望設置在內部&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;下列兩個工作會切換工作平台，例如 Github
&lt;ul&gt;
&lt;li&gt;review，檢視 difference，與討論&lt;/li&gt;
&lt;li&gt;PR&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;review 完有時會忘記 merge，merge 完有時會忘記 apply
&lt;ul&gt;
&lt;li&gt;repository 越多，忘得越多&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;團隊已經導入 Git-flow，希望把工作流程做得更完整自動化更加便利&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.runatlantis.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Atlantis 解決方案&lt;/a&gt;是與版本控制整合，提供 terraform 執行的 worker，病可以與 Git Host (e.g. Github) 整合做 PR + Review，來達成持續的 CI/CD 遠端執行，自動 plan 與自動 apply merge。也就是 Atlantis 幫我們處理以下幾件事&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Git-flow&lt;/li&gt;
&lt;li&gt;TODO 自動化 plan&lt;/li&gt;
&lt;li&gt;TODO Webhook 回傳 plan 結果&lt;/li&gt;
&lt;li&gt;TODO 透過 bot 控制 apply&lt;/li&gt;
&lt;li&gt;TODO 自動 merge&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;需求與工作流程&#34;&gt;需求與工作流程&lt;/h1&gt;
&lt;p&gt;以下的範例使用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Github 作為版本控管工具
&lt;ul&gt;
&lt;li&gt;是整個工作流程的控制中心&lt;/li&gt;
&lt;li&gt;tf code，review，plan，apply 的結果都會在 Github&lt;/li&gt;
&lt;li&gt;進一步整合到 Slack 上也非常方便&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Atlantis 放在 Kubernetes 上
&lt;ul&gt;
&lt;li&gt;使用 helm chart 部署&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果需要其他的版本控制工具或是安裝方式，請見&lt;a href=&#34;https://www.runatlantis.io/docs/installation-guide.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Atlantis 官方文件&lt;/a&gt;，Atlantis 支援非常多版本控制工具，例如 Github，Gitlab，Bitbucket，&amp;hellip;等&lt;/p&gt;
&lt;p&gt;整個工作流程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Github commit push
&lt;ul&gt;
&lt;li&gt;Github event -&amp;gt; Atlantis webhook&lt;/li&gt;
&lt;li&gt;Atlantis run terraform validate plan&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Github PR push
&lt;ul&gt;
&lt;li&gt;Github event -&amp;gt; Atlantis webhook&lt;/li&gt;
&lt;li&gt;Atlantis run terraform validate plan&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Github Merge event / main branch push
&lt;ul&gt;
&lt;li&gt;Github event -&amp;gt; Atlantis webhook&lt;/li&gt;
&lt;li&gt;Atlantis run terraform validate plan&lt;/li&gt;
&lt;li&gt;Atlantis acquire access to site (dev / stage)&lt;/li&gt;
&lt;li&gt;Atlantis apply to site&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Github release tag push (eg. 1.2.0-rc)
&lt;ul&gt;
&lt;li&gt;Github event -&amp;gt; Atlantis webhook&lt;/li&gt;
&lt;li&gt;Atlantis run terraform validate plan&lt;/li&gt;
&lt;li&gt;Atlantis acquire access to site (dev/stage)&lt;/li&gt;
&lt;li&gt;Atlantis apply to site (release-candidate / prod)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;依據上面的環境，安裝需要準備以下幾個東西&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Git
&lt;ul&gt;
&lt;li&gt;Git Host 上設定 Atlantis 存取 Git Repository 的權限&lt;/li&gt;
&lt;li&gt;為 Git Host 設定存取私鑰，讓 Atlantis 認證 webhook&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Terraform Backend State storage: Atlantis 需要存取外部的 state storage&lt;/li&gt;
&lt;li&gt;Terraform 使用的版本要注意一下。Atlantis 可以支援不同 repository / project 使用不同版本&lt;/li&gt;
&lt;li&gt;Environment credential (provider credential)
&lt;ul&gt;
&lt;li&gt;Atlantis 會需要存取不同的環境 (dev / stage / prod)&lt;/li&gt;
&lt;li&gt;為這些環境獨立配置 credential 讓 Atlantis 存取&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;實際 Atlantis 的環境會有&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Docker 作為孤城師本機開發測試使用&lt;/li&gt;
&lt;li&gt;Kubernetes Atlantis
&lt;ul&gt;
&lt;li&gt;我們的團隊會是一個環境一個獨立的 Atlantis
&lt;ul&gt;
&lt;li&gt;安全性：切分各個環境的權限與 Access&lt;/li&gt;
&lt;li&gt;各個 Atlantis webhook 只接收屬於自己的 event&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;docker&#34;&gt;Docker&lt;/h3&gt;
&lt;p&gt;使用 Docker 作為本地開發與測試的容器 runtime：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker pull runatlantis/atlantis:v0.15.0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker run runatlantis/atlantis:v0.15.0 atlantis \
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  --gh-user=GITHUB_USERNAME \
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  --gh-token=GITHUB_TOKEN
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;helm-chart&#34;&gt;Helm Chart&lt;/h3&gt;
&lt;p&gt;Helm 的安裝十分簡易&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;helm repo add runatlantis https://runatlantis.github.io/helm-charts
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;helm inspect values runatlantis/atlantis &amp;gt; values.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;更改 values.yaml&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;github:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  user: chechiachang
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  token: ...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  secret: ...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;orgWhitelist: github.com/chechiachang/*
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;安裝到 Kubernetes 上&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;helm install atlantis runatlantis/atlantis -f values.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;結果&#34;&gt;結果&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;工程師透過 Github 就可以完成所有工作
&lt;ul&gt;
&lt;li&gt;加上 Github Slack 整合，就完全不用離開 Slack，跟 bot 聊天就可以完成所有 terraform 工作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;安全穩定的 terraform 執行環境&lt;/li&gt;
&lt;li&gt;獨立的 in-cluster credential，集群的存取權限都控制在集群內，不會暴露到外部環境&lt;/li&gt;
&lt;li&gt;自動 plan 與 apply，不會遺忘&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;優劣&#34;&gt;優劣&lt;/h1&gt;
&lt;p&gt;優點&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以 self-hosted，credential 不外洩，確保最高的安全性&lt;/li&gt;
&lt;li&gt;已經整合 Kubernetes, helm chart&lt;/li&gt;
&lt;li&gt;webhook 整合許多版本控制庫，例如 github, gitlab,&amp;hellip;&lt;/li&gt;
&lt;li&gt;實現安全的遠端執行
&lt;ul&gt;
&lt;li&gt;本地執行還是會有諸多問題&lt;/li&gt;
&lt;li&gt;terraform cloud 提供的遠端執行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺點，其實沒什麼缺點&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;就需要多養一組 Atlantis
&lt;ul&gt;
&lt;li&gt;使用 stateless deployment，其實是應該不會有什麼負擔&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Terraform 系列至此應該是全部完結，感謝各位&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Terraform Infrastructure as Code: Terragrunt</title>
      <link>https://chechia.net/en/post/2020-10-06-terraform-infrastructure-as-code-terragrunt/</link>
      <pubDate>Tue, 06 Oct 2020 11:15:48 +0800</pubDate>
      <guid>https://chechia.net/en/post/2020-10-06-terraform-infrastructure-as-code-terragrunt/</guid>
      <description>&lt;p&gt;This article is part of &lt;a href=&#34;https://chechia.net/en/post/2020-06-14-terraform-infrastructure-as-code/&#34;&gt;從零開始的 Infrastructu as Code: Terraform&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/chechiachang/terraform-playground&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Get-started examples / SOP on Github&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://chechia.net/en/post/2020-06-15-terraform-infrastructure-as-code-transcript/&#34;&gt;Introducation to Terraform Iac: Speaker transcript&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://slides.com/chechiachang/terraform-introduction/edit&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Presentation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Check my website &lt;a href=&#34;https://chechia.net&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;chechia.net&lt;/a&gt; for other blog. &lt;a href=&#34;https://www.facebook.com/engineer.from.scratch&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Follow my page to get notification&lt;/a&gt;. Like my page if you really like it :)&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;上面講解 Terraform 的基本操作流程，提供範本原始碼，以及一步一步導入的詳細步驟。各位應該都可以依照上面幾篇的說明，開始快樂的使用 Terraform 了。&lt;/p&gt;
&lt;p&gt;而當使用 Terraform 的規模越來越大，管理的資料越來越多時，開始會出現一些問題，例如重複的 terraform code 越來越多，協同工作 review 不太容易，state 的內容管理與鎖管理，等等。這些問題可以透過一些工作流程的改進，或是導入新的小工具，來改善工作效率。&lt;/p&gt;
&lt;p&gt;接下來筆者推薦幾個心得與工具，希望能提升使用 Terraform 的效率與產值&lt;/p&gt;
&lt;p&gt;以下幾篇文章，適合已經使用過 terraform 一點時間，有經驗的團隊，並打算更大規模導入 terraform，正在尋求改善的方向。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;心得
&lt;ul&gt;
&lt;li&gt;CI/CD 全自動化&lt;/li&gt;
&lt;li&gt;State backend 選擇&lt;/li&gt;
&lt;li&gt;最佳實踐 &lt;a href=&#34;https://www.terraform.io/docs/cloud/guides/recommended-practices/index.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.terraform.io/docs/cloud/guides/recommended-practices/index.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;工具
&lt;ul&gt;
&lt;li&gt;Terraform Atlantis&lt;/li&gt;
&lt;li&gt;Terragrunt&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;問題與需求&#34;&gt;問題與需求&lt;/h1&gt;
&lt;p&gt;當團隊已經開始大規模使用 terraform，tf 檔案越來越多。我們為了增加程式碼的重複利用性，會使用 terraform module 將常用的 tf 檔案封裝。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;隨著導入的規模越來越大，這些 module 會越來越多，而且使用這些 module 的 project 也增加&lt;/li&gt;
&lt;li&gt;隨著管理的 infrastructure 越來越複雜，為了描述這些本來就很複雜的 infrastructure，module 不只越來越多，還會出現 module 引用其他 module，大 module 使用小 module 的 nested module
&lt;ul&gt;
&lt;li&gt;這點在複雜的 provider 中常出現，例如
&lt;ul&gt;
&lt;li&gt;使用 terraform 描述網路架構&lt;/li&gt;
&lt;li&gt;描述複雜的 IAM &amp;amp; Role&lt;/li&gt;
&lt;li&gt;terraform vault-provider&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;管理的環境越來越多，例如 dev, staging, prod,&amp;hellip;，每個環境都需要獨立的工作空間，造成大量重複的 tf code&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用一段時間 terraform ，很快就會發現的第一個問題是：不論怎麼從 tf 檔案中提取重複部分，做成 module，還是有很多部分的 tf code 是完全重複的，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每個 module 會定義的 variable (argument)，使用這個 module 的上層會需要提供傳入 variable&lt;/li&gt;
&lt;li&gt;每個 module 都會需要提供 provider&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Terraform 的語法要求上面這些參數都明確的定義，這讓整個 module 或資料夾的描述非常清楚。但會處就是，這些描述的參數道出都是，而且不斷的重複，每個 module 或資料夾都要提供，不然在 terraform validate 時會因為應提供參數未提供，導致錯誤。雖然立意良好，但卻嚴重違反 DRY (Don&amp;rsquo;t Repeat Yourself) 的原則&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;module 多層引用，project 引用大 module，大 module 又引用小 module&lt;/li&gt;
&lt;li&gt;開始感覺 backend 與 provider 的 code 比其他功能 code 多了&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有沒有可能用其他工具，避免這些重複的參數，backend，provider 等等？&lt;/p&gt;
&lt;h1 id=&#34;terragrunt&#34;&gt;Terragrunt&lt;/h1&gt;
&lt;p&gt;推薦有大量使用的團隊，直接使用 &lt;a href=&#34;https://terragrunt.gruntwork.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Terragrunt&lt;/a&gt; 這款工具。&lt;/p&gt;
&lt;p&gt;他是一層 terraform 的 wrapper&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;i.e. 執行 terraform plan -&amp;gt; terragrunt plan&lt;/li&gt;
&lt;li&gt;terragrunt 會先解析，產生重複的 code，然後再執行 terraform&lt;/li&gt;
&lt;li&gt;編輯時只要寫一次，terragrunt 代為在其他地方產生重複的 code&lt;/li&gt;
&lt;li&gt;產生的 code 會被隱藏與 cache&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Terragrunt 有許多功能，例如&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;處理 Backend，provider，與其他不斷重複的 tf code&lt;/li&gt;
&lt;li&gt;處理多環境下重複的 tf&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;a href=&#34;https://terragrunt.gruntwork.io/docs/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;完整功能請見官方文件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;導入 Terragrunt 可以避免重複代碼，降低維護成本，提升生產效率&lt;/p&gt;
&lt;h1 id=&#34;使用情境&#34;&gt;使用情境&lt;/h1&gt;
&lt;p&gt;上述說明可能不太清楚，我們實際看範例，以&lt;a href=&#34;https://github.com/chechiachang/terraform-playground&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;前幾篇我們使用的範例 repository&lt;/a&gt; 為例子，把 gcp 的資料夾目錄應該長這樣：&lt;/p&gt;
&lt;p&gt;可以很清楚見到底下幾個東西不斷重複
由於 my-new-project, gke-playground, national-team-5g 三個專案是獨立的專案，各自可以獨立運行。但其實同屬於同公司的專案，可能許多內容都是重複的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;tree gcp
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;gcp
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;├── README.md
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;├── Makefile
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;├── my-new-project/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;│   ├── terraform.tf
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;│   ├── terraform.tfvars
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;│   ├── variable.tf
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;│   └── provider.tf
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;├── gke-playground/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;│   ├── terraform.tf
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;│   ├── terraform.tfvars
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;│   ├── variable.tf
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;│   └── provider.tf
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;├── national-team-5g/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;│   ├── dev
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;│   │   ├── terraform.tf
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;│   │   ├── terraform.tfvars
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;│   │   ├── variable.tf
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;│   │   └── provider.tf
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;│   ├── stag
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;│   │   ├── terraform.tf
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;│   │   ├── terraform.tfvars
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;│   │   ├── variable.tf
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;│   │   └── provider.tf
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;│   └── prod
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;│       ├── terraform.tf
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;│       ├── terraform.tfvars
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;│       ├── variable.tf
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;│       └── provider.tf
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;├── templates/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;└── modules/
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以很清楚見到底下幾個東西不斷重複&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;provider.tf 這裡描述使用的 provider，這邊只有使用 gcp provider，所以是完全一樣重複&lt;/li&gt;
&lt;li&gt;variable.tf 是定義的參數&lt;/li&gt;
&lt;li&gt;terraform.tfvars 是傳入的參數，也就是實際各專案各自的執行參數&lt;/li&gt;
&lt;li&gt;national-team-5g 的專案下，又各自拆分多個執行環境，每個環境獨立，所以又有許多重複的 code&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這邊的目的，是有系統化的處理這些重複的代碼&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;gcp
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;├── terraform.tfvars        # gcp 共用的參數
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;├── terragrunt.hcl          # gcp 共用的程式碼
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;├── national-team-5g/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;│   ├── terraform.tfvars    # national-team-5g 共用的參數
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;│   ├── terragrunt.hcl      # national-team-5g 共用的程式碼
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;│   ├── dev
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;│   │   ├── terraform.tfvars  # dev 的參數
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;│   │   └── terragrunt.hcl    # dev 環境自己的程式碼
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;│   ├── staging
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;│   │   ├── terraform.tfvars  # staging 的參數
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;│   │   └── terragrunt.hcl    # staging 環境自己的程式碼
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;│   └── prod
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;│       ├── terraform.tfvars  # prod 的參數
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;│       └── terragrunt.hcl    # prod 環境自己的程式碼
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;差異非常多是吧，但這邊只是從資料目錄結構看，其實如果從 tf 檔案內部的程式碼看，裡面的代碼更是精簡到不行，用起來非常的爽XD&lt;/p&gt;
&lt;h1 id=&#34;安裝&#34;&gt;安裝&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;去 release 頁面找適合的執行檔案&lt;/li&gt;
&lt;li&gt;下載&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;chmod u+x terragrunt
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;mv terragrunt /usr/local/bin/terragrunt
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;a href=&#34;https://terragrunt.gruntwork.io/docs/getting-started/quick-start/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;詳細文件請見&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;範例&#34;&gt;範例&lt;/h1&gt;
&lt;p&gt;Terragrunt 的 DRY feature，其實內容都大同小異&lt;/p&gt;
&lt;p&gt;├── national-team-5g/
│   ├── dev
│   │   ├── terraform.tfvars  # staging 的參數
│   │   └── provider.tf
│   ├── stag
│   │   ├── terraform.tfvars  # staging 的參數
│   │   └── provider.tf
│   └── prod
│       ├── terraform.tfvars  # prod 的參數
│       └── provider.tf&lt;/p&gt;
&lt;p&gt;例如&lt;/p&gt;
&lt;p&gt;national-team-5g/dev/provider.tf&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;provider &amp;#34;google&amp;#34; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  version = &amp;#34;~&amp;gt;v3.25.0&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  credentials = file(var.credential_json)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  project = var.project
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  region  = var.region
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;改成&lt;/p&gt;
&lt;p&gt;national-team-5g/dev/terragrunt.hcl&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;generate &amp;#34;provider&amp;#34; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  path      = &amp;#34;provider.tf&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  if_exists = &amp;#34;overwrite&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  contents = &amp;lt;&amp;lt;EOF
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;provider &amp;#34;google&amp;#34; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  version = &amp;#34;~&amp;gt;v3.25.0&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  credentials = file(var.credential_json)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  project = var.project
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  region  = var.region
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;EOF
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;執行&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cd national-team-5g/dev
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;terragrunt plan
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;關於參數&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;var.region 是本地參數，可以依據 dev/staging/prod 參數各自設定&lt;/li&gt;
&lt;li&gt;var.project 這個是整個 national-team-5g 都共用的參數，可以進一步提高到更上層
&lt;ul&gt;
&lt;li&gt;i.g. 放在 national-team-5g/terraform.tfvars 檔案裡面，透過 terragrunt.hcl 傳遞。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;functions&#34;&gt;Functions&lt;/h1&gt;
&lt;p&gt;tf 檔案，在許多 block 中禁止使用 variable，這層限制有其考量，但是缺點是造成許多 hard coded 的程式碼。&lt;/p&gt;
&lt;p&gt;Terragrunt 產生的程式碼，由於是在 terragrunt 執行後，terraform 執行前，因次沒有這層限制，可以做許多事情，例如 code generate 以及 function 運算，terragrunt 提供許多內建 function，這邊只介紹常用幾個。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;&#34;&gt;find_in_parent_folder()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;&#34;&gt;path_relative_to_include()&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;範例兩個檔案&lt;/p&gt;
&lt;p&gt;project/dev/terraform.hcl&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;include {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  path = find_in_parent_folders()
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;project/terraform.hcl&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;env = path_relative_to_include()
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最後 parse 後的結果&lt;/p&gt;
&lt;p&gt;project/dev/terraform.hcl&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;env = &amp;#34;dev&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;做了兩件事&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;要求 project/dev 去上層尋找 terraform.hcl，並且引入其中的設定 (env=&amp;quot;&amp;quot;)
&lt;ul&gt;
&lt;li&gt;子專案可以 include 母資料夾的程式碼&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;匯入上層 project 時，寫入相對的路徑 (dev)，並且帶入 (env=&amp;ldquo;dev&amp;rdquo;)
&lt;ul&gt;
&lt;li&gt;母專案可以為各個子目錄配置相對路徑&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://terragrunt.gruntwork.io/docs/reference/built-in-functions/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;其他內建 function 請見官方文件&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;小結&#34;&gt;小結&lt;/h1&gt;
&lt;p&gt;Terragrunt 可以精簡程式碼，大福提升生產效率，然而在還不熟悉 terraform 核心功能之前，不建議過早導入，會導致多餘的學習成本。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Terraform Infrastructure as Code: Recommended Practices</title>
      <link>https://chechia.net/en/post/2020-10-05-terraform-infrastructure-as-code-recommended-practices/</link>
      <pubDate>Mon, 05 Oct 2020 11:15:48 +0800</pubDate>
      <guid>https://chechia.net/en/post/2020-10-05-terraform-infrastructure-as-code-recommended-practices/</guid>
      <description>&lt;p&gt;This article is part of &lt;a href=&#34;https://chechia.net/en/post/2020-06-14-terraform-infrastructure-as-code/&#34;&gt;從零開始的 Infrastructu as Code: Terraform&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/chechiachang/terraform-playground&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Get-started examples / SOP on Github&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://chechia.net/en/post/2020-06-15-terraform-infrastructure-as-code-transcript/&#34;&gt;Introducation to Terraform Iac: Speaker transcript&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://slides.com/chechiachang/terraform-introduction/edit&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Presentation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Check my website &lt;a href=&#34;https://chechia.net&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;chechia.net&lt;/a&gt; for other blog. &lt;a href=&#34;https://www.facebook.com/engineer.from.scratch&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Follow my page to get notification&lt;/a&gt;. Like my page if you really like it :)&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;上面講解 Terraform 的基本操作流程，提供範本原始碼，以及一步一步導入的詳細步驟。各位應該都可以依照上面幾篇的說明，開始快樂的使用 Terraform 了。&lt;/p&gt;
&lt;p&gt;以下幾篇文章，適合已經使用過 terraform 一點時間，有經驗的團隊，並打算更大規模導入 terraform，正在尋求改善的方向。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;心得
&lt;ul&gt;
&lt;li&gt;CI/CD 全自動化&lt;/li&gt;
&lt;li&gt;State backend 選擇&lt;/li&gt;
&lt;li&gt;最佳實踐&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;工具
&lt;ul&gt;
&lt;li&gt;Terraform Atlantis&lt;/li&gt;
&lt;li&gt;Terragrunt&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;工具與文化&#34;&gt;工具與文化&lt;/h1&gt;
&lt;p&gt;新工具提供解決方案，然而單純導入工具後不是就一勞永逸，許多實務上的問題，還是要依賴改善工作流程，並且避免整體運作的錯誤。&lt;/p&gt;
&lt;p&gt;其次，不同團隊已有既有的團隊文化，整合新的工具後還是需要磨合，不一定要照單全收。換句話說，工作流程的不斷改進也是解決方案的一環。&lt;/p&gt;
&lt;h1 id=&#34;建議實踐-recommended-practices&#34;&gt;建議實踐 Recommended Practices&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.terraform.io/docs/cloud/guides/recommended-practices/index.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Terraform 官網有許多建議的實作與導入流程&lt;/a&gt;，其中大部分的建議我們都已經在前面的幾篇文章中提到，這邊要來說明一下，並補充其他官方推薦的實踐。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;技術複雜度: 隨著架構的複雜增加，維護整體架構的困難逐漸增加&lt;/li&gt;
&lt;li&gt;組織複雜度: 隨著團隊規模增長，分工與權責越顯複雜，團隊的協作困難逐漸增加&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Terraform 的目的，在於減少上面兩者的複雜度。&lt;/p&gt;
&lt;h1 id=&#34;工作目錄結構&#34;&gt;工作目錄結構&lt;/h1&gt;
&lt;p&gt;工作目錄 (workspace) 是 terraform 運作的基準點，容納 tf 檔案，通常會使用版本控制工具管理。&lt;/p&gt;
&lt;h1 id=&#34;一個環境一個工作目錄&#34;&gt;一個環境一個工作目錄&lt;/h1&gt;
&lt;p&gt;這個我們在前面的範例已經實踐，基本上目錄為&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;project (git repository)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;├── api-server/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;│   ├── dev
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;│   │   └── terraform.tf
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;│   ├── stage
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;│   │   └── terraform.tf
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;│   └── prod
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;│       └── terraform.tf
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;├── grpc-server/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;│
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;將產品或專案切割成各自獨立的環境，以某專案的某環境作為管理單位&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;project-api-server-dev&lt;/li&gt;
&lt;li&gt;project-api-server-stage&lt;/li&gt;
&lt;li&gt;project-api-server-prod&lt;/li&gt;
&lt;li&gt;project-grpc-server-dev&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這麼做有幾個好處：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;確保產品與環境的獨立
&lt;ul&gt;
&lt;li&gt;彼此不互相影響&lt;/li&gt;
&lt;li&gt;但又可確保彼此的關連性，例如架構相同&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;以環境的為管理單位，換句話說，一組完整的環境 直接對應到 一組完整的工作目錄
&lt;ul&gt;
&lt;li&gt;管理上非常直觀明確&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用工作目錄分配權限與權責
&lt;ul&gt;
&lt;li&gt;直接為不同團隊分配不同工作目錄的存取權限&lt;/li&gt;
&lt;li&gt;權責與工作目錄的明確對應&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;持續評估與改進&#34;&gt;持續評估與改進&lt;/h1&gt;
&lt;p&gt;自動化程度也是工作流程進步的指標：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;手動控制&lt;/li&gt;
&lt;li&gt;半自動化&lt;/li&gt;
&lt;li&gt;全自動化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;導入 terraform 後的我們已經描述過了，內容詳情請見上上篇文章。下面描述官方推薦的從最開始，完全沒有 terraform 經驗開始導入流程，以筆者個人於公司從零開始導入的經驗，非常直得參考。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如何從完全手動操作，變成半自動操作&lt;/li&gt;
&lt;li&gt;如何從半自動，變成 IaC (infrastructure as code)&lt;/li&gt;
&lt;li&gt;如何從 IaC，變成 IaC 多人協作&lt;/li&gt;
&lt;li&gt;進階改進 IaC 多人協作&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;如何從完全手動操作變成半自動操作&#34;&gt;如何從完全手動操作，變成半自動操作&lt;/h1&gt;
&lt;p&gt;如果團隊應該是還在完全手動控制 infrastructure&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查驗 (audit) 困難&lt;/li&gt;
&lt;li&gt;無法複現 (reproduce)&lt;/li&gt;
&lt;li&gt;拓展 (scale) 困難&lt;/li&gt;
&lt;li&gt;很難分享 infrastructure 的知識&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第一步要執行的是：選擇少部分，可以控制的 infrastructure 開始導入 terraform。所以要做的就是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;開始使用 terraform&lt;/li&gt;
&lt;li&gt;如果需要可以參考一些範例專案
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://learn.hashicorp.com/collections/terraform/aws-get-started?utm_source=WEBSITE&amp;amp;utm_medium=WEB_IO&amp;amp;utm_offer=ARTICLE_PAGE&amp;amp;utm_content=DOCS&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Terraform: Get Started collection&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;開始進入半自動階段後，團隊中的少部分人員開始使用 terraform，手上也有了可運作的少部分 infrastructure as code，可以作為 demo ，或是其他團隊成員的教育訓練，這個可以幫助下一階段的演進。&lt;/p&gt;
&lt;h1 id=&#34;如何從半自動變成-iac-infrastructure-as-code&#34;&gt;如何從半自動，變成 IaC (infrastructure as code)&lt;/h1&gt;
&lt;p&gt;目前半自動的工作專案內容應該是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Terraform code&lt;/li&gt;
&lt;li&gt;手動操作的流程&lt;/li&gt;
&lt;li&gt;一些輔助腳本&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下個階段希望繼續推展 terraform 的使用，降低手動步驟與腳本執行。這個階段可以做的事情&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用版本控制管理 tf code
&lt;ul&gt;
&lt;li&gt;這邊假設團隊本來就有使用版本控制，開始將 tf code 導入版本控制的工作流程&lt;/li&gt;
&lt;li&gt;開始將先產生的 tf code 移入版本控制&lt;/li&gt;
&lt;li&gt;所有團隊都能共享新 tf code 的知識&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;開始使用第一個 terraform module
&lt;ul&gt;
&lt;li&gt;一個簡單的方式是將重複使用的 infrastructure 抽出，減少重複的 tf code&lt;/li&gt;
&lt;li&gt;這邊需要提醒，盡量以完整個 infrastructure 作為單位抽離 tf code 作為 module
&lt;ul&gt;
&lt;li&gt;完整的 infrastructure 也是在 provider 中間轉成的單位&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;持續推廣團隊內 terraform 的使用&lt;/li&gt;
&lt;li&gt;開始設定工作準則 (Guidelines) 來描述並規範工作流程
&lt;ul&gt;
&lt;li&gt;在團隊上不完全熟悉 terraform 前，可以提升工作效率，推廣最佳實踐，並且降低錯誤風險&lt;/li&gt;
&lt;li&gt;團隊的架構師可以依據團隊文化形塑工作流程，更符合團隊需求&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;開始導入 configuration management
&lt;ul&gt;
&lt;li&gt;例如 Chef cookbook&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;私鑰與隱秘資訊管理
&lt;ul&gt;
&lt;li&gt;導入 vault 來管理&lt;/li&gt;
&lt;li&gt;terraform 整合 vault，可以使用 terraform 管理 vault 的結構，使用 vault 來管理 terraform 所需的 credentials&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;如何從-iac變成-iac-多人協作&#34;&gt;如何從 IaC，變成 IaC 多人協作&lt;/h1&gt;
&lt;p&gt;導入版本控制可以降低堆人協作的複雜度，下個階段需要&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;統一跨團隊的工作流程&lt;/li&gt;
&lt;li&gt;使用 terraform 管理團隊的 IAM 權限&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以執行的改進如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;官方推薦使用 Terraform Cloud 來做後台，我們稍候推薦的幾個免費工具也有相似功能，團隊可以參考使用。這邊專注在需求與方法。&lt;/li&gt;
&lt;li&gt;開始設計整個組織間的工作目錄結構
&lt;ul&gt;
&lt;li&gt;工作目錄要反映
&lt;ul&gt;
&lt;li&gt;獨立的環境與獨立的專案&lt;/li&gt;
&lt;li&gt;負責管理的團隊組織，已分配存取權限&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;這部分的實作後面的文章也會提到&lt;/li&gt;
&lt;li&gt;官方推薦的 Terraform Cloud 可見&lt;a href=&#34;https://www.terraform.io/docs/cloud/guides/recommended-practices/part3.3.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;官方文件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;進階改進-iac-多人協作&#34;&gt;進階改進 IaC 多人協作&lt;/h1&gt;
&lt;p&gt;如今團隊已經有多人協作的介面，也有完整的工作流程，我們可以藉由以下改進，達成更堅固的框架&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;官方建議大量導入 Terraform Cloud，但這會超出免費額度&lt;/li&gt;
&lt;li&gt;我們之後的文章會提供開源版本的解法
&lt;ul&gt;
&lt;li&gt;簡化工作目錄的管理&lt;/li&gt;
&lt;li&gt;明確的 review 與 audit 工作流程&lt;/li&gt;
&lt;li&gt;增加 infrastructure 的監測與效能監控，這些都可以使用 terraform 設置&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具體實作，請見下篇文章&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Terraform Infrastructure as Code: Backends</title>
      <link>https://chechia.net/en/post/2020-10-04-terraform-infrastructure-as-code-backend/</link>
      <pubDate>Sun, 04 Oct 2020 11:15:48 +0800</pubDate>
      <guid>https://chechia.net/en/post/2020-10-04-terraform-infrastructure-as-code-backend/</guid>
      <description>&lt;p&gt;This article is part of &lt;a href=&#34;https://chechia.net/en/post/2020-06-14-terraform-infrastructure-as-code/&#34;&gt;從零開始的 Infrastructu as Code: Terraform&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/chechiachang/terraform-playground&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Get-started examples / SOP on Github&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://chechia.net/en/post/2020-06-15-terraform-infrastructure-as-code-transcript/&#34;&gt;Introducation to Terraform Iac: Speaker transcript&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://slides.com/chechiachang/terraform-introduction/edit&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Presentation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Check my website &lt;a href=&#34;https://chechia.net&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;chechia.net&lt;/a&gt; for other blog. &lt;a href=&#34;https://www.facebook.com/engineer.from.scratch&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Follow my page to get notification&lt;/a&gt;. Like my page if you really like it :)&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;上面講解 Terraform 的基本操作流程，提供範本原始碼，以及一步一步導入的詳細步驟。各位應該都可以依照上面幾篇的說明，開始快樂的使用 Terraform 了。&lt;/p&gt;
&lt;p&gt;而當使用 Terraform 的規模越來越大，管理的資料越來越多時，開始會出現一些問題，例如重複的 terraform code 越來越多，協同工作 review 不太容易，state 的內容管理與鎖管理，等等。這些問題可以透過一些工作流程的改進，或是導入新的小工具，來改善工作效率。&lt;/p&gt;
&lt;p&gt;接下來筆者推薦幾個心得與工具，希望能提升使用 Terraform 的效率與產值&lt;/p&gt;
&lt;p&gt;以下幾篇文章，適合已經使用過 terraform 一點時間，有經驗的團隊，並打算更大規模導入 terraform，正在尋求改善的方向。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;心得
&lt;ul&gt;
&lt;li&gt;CI/CD 全自動化&lt;/li&gt;
&lt;li&gt;State backend 選擇&lt;/li&gt;
&lt;li&gt;最佳實踐 &lt;a href=&#34;https://www.terraform.io/docs/cloud/guides/recommended-practices/index.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.terraform.io/docs/cloud/guides/recommended-practices/index.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;工具
&lt;ul&gt;
&lt;li&gt;Terraform Atlantis&lt;/li&gt;
&lt;li&gt;Terragrunt&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;terraform-backend&#34;&gt;Terraform Backend&lt;/h1&gt;
&lt;p&gt;剛開始使用 terraform 的時候，大家的第一個範例應該都是 local backend 吧，就是直接在本地 terraform apply，在目前的工作目錄下產生 state 檔案。這個 state 檔案直接 cat 打開來看後，可以發現裡面一切都是明碼的。初學時筆者感覺所謂的 Terraform backend 只是一個存放中繼的 state 資料的 workspace，後來發現完全不是這麼回事，便立刻棄用了 local backend。&lt;/p&gt;
&lt;p&gt;之後依照官方推薦就使用了 &lt;a href=&#34;https://app.terraform.io/app&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Terraform Cloud&lt;/a&gt;，後來便出現許多問題，等等會分析。&lt;/p&gt;
&lt;p&gt;最後團隊選用了自家公有雲的 backend，例如&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AWS S3 作為 state storage，DynamoDB 作為中心化的 workflow lock&lt;/li&gt;
&lt;li&gt;GCP&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://www.terraform.io/docs/backends/index.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;完整 terraform backend 支援清單可以見官方網站&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;這篇文章要來仔細探討所謂的 terraform backend，backend 的重要性，與如選擇適合自己團隊的 backend。&lt;/p&gt;
&lt;h1 id=&#34;問題&#34;&gt;問題&lt;/h1&gt;
&lt;p&gt;如果使用 tf random 產生亂數密碼，直接去 cat state 檔案就可以看到明碼的 random 數值。&lt;/p&gt;
&lt;p&gt;多人協作 lock&lt;/p&gt;
&lt;p&gt;另外一個解法是，根本不使用 backend，terraform 也支援這樣的做法。雖然&lt;a href=&#34;https://www.terraform.io/docs/backends/index.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;官方也明講 backend are completely optional&lt;/a&gt;，但依照筆者的經驗，強烈建議多人團隊務必去啟用，並找尋適合自己的 Backend。&lt;/p&gt;
&lt;h1 id=&#34;需求&#34;&gt;需求&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;資訊安全，希望 terraform 使用是安全的，不會暴露敏感資訊&lt;/li&gt;
&lt;li&gt;多人協作，希望可以同時工作，但又不會互相衝突&lt;/li&gt;
&lt;li&gt;遠端操作，避免本地操作&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;state-存放與鎖&#34;&gt;State 存放與鎖&lt;/h1&gt;
&lt;p&gt;預設的 backend 是 loal backend，也就是執行 terraform apply 後，本地會出現一個 JSON 格式的 state 檔案。然而 local state 會立刻遇到的問題，就是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一個是協作困難，apply 的結果別人看不到，不能接續著做&lt;/li&gt;
&lt;li&gt;每個人都可以 apply&lt;/li&gt;
&lt;li&gt;但不同人的 apply 沒有相依性
&lt;ul&gt;
&lt;li&gt;可是遠端的 infrastructure 有，A B 不同人一起 apply 到 infrastructure 上，可寧就會衝突，或是產生不可預期的錯誤&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以筆者強烈推薦使用外部的 backend 來取代 local backend。多半 backend 會多做許多事，透過控制 state 來確保 infrastrure 的完整性，例如對 state 存取有以下的限制:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ａ透過鎖來控制，禁止多人同時存取，例如同時有兩個人 apply 相同或不同檔案，先取得 backend lock 的人執行，後來的人會被 terraform 阻擋
&lt;ul&gt;
&lt;li&gt;避免多頭馬車的問題&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;確保 state 的唯一性，使用另外一個 repo 的 state 檔案，遠端的 state 會拒絕存取&lt;/li&gt;
&lt;li&gt;確保 state 的順序，每次 apply 的 state 都是依序產生
&lt;ul&gt;
&lt;li&gt;如果 state 是舊的，可能就會被遠端的 backend 拒絕，避免使用舊的 apply 覆蓋新的 infrastructure&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這些限制，如果使用 local backend 才會容易遇到，使用外部的 backend 其實不容易會發生。Terraform 基於 Infrastructure as Code 實現，可以將整個 terraform repo 視為 code 一部分，這樣就可以想像為何這些 state 限制是重要的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;state 跟隨 tf 檔案，隨著 tf 檔案的 commit 推進，state 也跟著推進&lt;/li&gt;
&lt;li&gt;commit 1 的 tf 檔案，apply 後產生 state 1&lt;/li&gt;
&lt;li&gt;如果今天有團隊 force push 了一個 conflict 的 tf 檔案，硬要 apply 的結果也可能造成 infrastructure conflicts&lt;/li&gt;
&lt;li&gt;如果今天團隊有多個 branch 同時開發，branch A apply 的 state 會與 branch B apply 的 state 也可能造成衝突&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;state-手動更改&#34;&gt;State 手動更改&lt;/h1&gt;
&lt;p&gt;在很特殊的狀況下，你也可以手動更改 state file，然後 push 上傳，但這點非常不建議，terraform 會自動維護 state 的完整性，手動更改可能會直接破壞正常的 state。什麼情形會用到？就是你的 state 因為某個原因被玩壞，大部分是人為弄壞的。這時候才被迫要手動更改 state。手動更改 state ，講白了不做死就不會死。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;vault state pull
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;vim your-local-state-file
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;# Increment Serial if needed
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;vault state push
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;# vault state push -force
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;hosted-terraform-cloud&#34;&gt;Hosted: Terraform Cloud&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://app.terraform.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Terraform Cloud&lt;/a&gt;，是官方提供的解決方案，有提供較多功能，例如在 terraform cloud 的網站上遠端 plan。有提供免費版，提供最多 5 人團隊使用。也有提供進階的方案 $20/user 或是 $70/user，以及 enterprise 版本，可以本地安裝。&lt;/p&gt;
&lt;p&gt;使用很簡單，&lt;a href=&#34;https://github.com/chechiachang/terraform-playground&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;我在前幾篇提供的範例 repository&lt;/a&gt;全部都是使用 terraform cloud 作為 Backend。提供&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;遠端的 state 儲存庫
&lt;ul&gt;
&lt;li&gt;所有團隊成員使用各自帳號登入&lt;/li&gt;
&lt;li&gt;plan 之前會 sync terraform cloud 上面的 state&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;遠端的 state lock
&lt;ul&gt;
&lt;li&gt;如果 lock 被人佔據，表示有其他人正在使用，會取消新的操作，避免衝突&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;也提供線上檢視 state ，或是線上修改 state 的功能
&lt;ul&gt;
&lt;li&gt;貼心小功能，但多半用不到&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;託管的 Terraform Cloud 作為 backend 他有幾個問題&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果要啟用遠端 plan，需要綁定版本控制服務器，例如綁定 Github 或 Gitlab
&lt;ul&gt;
&lt;li&gt;基於安全性考量，這點很多公司就直接打槍了
&lt;ul&gt;
&lt;li&gt;暴露原始碼給第三方公司，可能會讓公司的安全性檢驗不過&lt;/li&gt;
&lt;li&gt;加上 terraform 的 Git Code，基本上就是所有 infrastructure 的資訊&lt;/li&gt;
&lt;li&gt;加上如果有使用 terraform 編輯 IAM 或是 provision vault，等於許多敏感資料都會出現在 terraform repository 中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果是重視安全性的團隊，則至少要使用可以 self-hosted 的 Terraform Enterprise，而不要使用公有的 Terraform Cloud。然而 Enterprise 我是沒用過，請不要問我價錢。&lt;/p&gt;
&lt;h1 id=&#34;consul&#34;&gt;Consul&lt;/h1&gt;
&lt;p&gt;Consul 嚴格來說不是單純的儲存庫，他是 Service Networking 設定與服務發現的解決方案，只是本身帶有 key value 的儲存功能，就被自家整合。換句話說，他不是專門拿來做 terraform backend 的，比較像是如果團隊本來就有使用 consul，可以考慮公用儲存庫，作為 terraform backend。&lt;/p&gt;
&lt;p&gt;這是相同公司 Hashicorp 提供的自家的 backend，整合的很完整。但就只是單純的儲存庫，沒有 terraform cloud 的遠端執行啊，或是線上檢視 state 檔案的功能。&lt;/p&gt;
&lt;p&gt;可以在公司內部自行架設一組 cluster，然後就可以作為 backend。&lt;/p&gt;
&lt;p&gt;問題是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Consul 這麼大一包，結果只使用了裡面的 kv store&lt;/li&gt;
&lt;li&gt;Consul 是分散式的 Key-value store，不熟悉的話不太好養
&lt;ul&gt;
&lt;li&gt;換句話說，如果死了救得起來嗎&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;etcd&#34;&gt;Etcd&lt;/h1&gt;
&lt;p&gt;Etcd 跟 consul 類似，雖然是專業的儲存庫，但是使用這麼複雜的分散式儲存庫，只作為 terraform 的 backend，顯然很不經濟。&lt;/p&gt;
&lt;p&gt;可以在公司內部自行架設一組 cluster，然後就可以作為 backend。&lt;/p&gt;
&lt;p&gt;一樣只建議已經有在使用 etcd ，且熟悉維運 etcd 的團隊，才考慮使用 etcd 兼作為 terraform backend。&lt;/p&gt;
&lt;p&gt;這些分散式的儲存庫，不太容易死，然而萬一死了可能不太好救。&lt;/p&gt;
&lt;h1 id=&#34;public-cloud&#34;&gt;Public Cloud&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.terraform.io/docs/backends/types/s3.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;AWS S3 + DynamoDB&lt;/a&gt;
&lt;a href=&#34;https://www.terraform.io/docs/backends/types/azurerm.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GCP gcs + pg&lt;/a&gt;
&lt;a href=&#34;https://www.terraform.io/docs/backends/types/gcs.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Azurerm + pg&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;只有單純的 state storage 與 lock 的功能，沒有什麼花俏的線上執行或是快速 review。&lt;/p&gt;
&lt;p&gt;好處是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用非常單純&lt;/li&gt;
&lt;li&gt;也是處在安全的內網環境中&lt;/li&gt;
&lt;li&gt;有於是公有雲提供的服務，基本的 IAM 與權限控管可以直接應用&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;postgresql&#34;&gt;Postgresql&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.terraform.io/docs/backends/types/pg.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Postgrel 也是一個不錯的選擇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Terraform 並不會帶來大量的資料庫負擔，所以可能會把 terraform 與附載較低的應用，共用資料庫。&lt;/p&gt;
&lt;p&gt;使用上作為 state storage 與 lock 很單純沒什麼問題&lt;/p&gt;
&lt;h1 id=&#34;其他&#34;&gt;其他&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.terraform.io/docs/backends/types/index.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;官方還有提供所有支援的 backend&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果 Kubernetes 還有做其他事情的話，請不要用 Kubernetes secret 作為 terraform 的 backend&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Terraform Infrastructure as Code: CI/CD automation</title>
      <link>https://chechia.net/en/post/2020-10-03-terraform-infrastructure-as-code-automation/</link>
      <pubDate>Sat, 03 Oct 2020 11:15:48 +0800</pubDate>
      <guid>https://chechia.net/en/post/2020-10-03-terraform-infrastructure-as-code-automation/</guid>
      <description>&lt;p&gt;This article is part of &lt;a href=&#34;https://chechia.net/en/post/2020-06-14-terraform-infrastructure-as-code/&#34;&gt;從零開始的 Infrastructu as Code: Terraform&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/chechiachang/terraform-playground&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Get-started examples / SOP on Github&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://chechia.net/en/post/2020-06-15-terraform-infrastructure-as-code-transcript/&#34;&gt;Introducation to Terraform Iac: Speaker transcript&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://slides.com/chechiachang/terraform-introduction/edit&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Presentation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Check my website &lt;a href=&#34;https://chechia.net&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;chechia.net&lt;/a&gt; for other blog. &lt;a href=&#34;https://www.facebook.com/engineer.from.scratch&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Follow my page to get notification&lt;/a&gt;. Like my page if you really like it :)&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;上面講解 Terraform 的基本操作流程，提供範本原始碼，以及一步一步導入的詳細步驟。各位應該都可以依照上面幾篇的說明，開始快樂的使用 Terraform 了。&lt;/p&gt;
&lt;p&gt;而當使用 Terraform 的規模越來越大，管理的資料越來越多時，開始會出現一些問題，例如重複的 terraform code 越來越多，協同工作 review 不太容易，state 的內容管理與鎖管理，等等。這些問題可以透過一些工作流程的改進，或是導入新的小工具，來改善工作效率。&lt;/p&gt;
&lt;p&gt;接下來筆者推薦幾個心得與工具，希望能提升使用 Terraform 的效率與產值&lt;/p&gt;
&lt;p&gt;以下幾篇文章，適合已經使用過 terraform 一點時間，有經驗的團隊，並打算更大規模導入 terraform，正在尋求改善的方向。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;心得
&lt;ul&gt;
&lt;li&gt;CI/CD 全自動化&lt;/li&gt;
&lt;li&gt;State backend 選擇&lt;/li&gt;
&lt;li&gt;最佳實踐 &lt;a href=&#34;https://www.terraform.io/docs/cloud/guides/recommended-practices/index.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.terraform.io/docs/cloud/guides/recommended-practices/index.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;工具
&lt;ul&gt;
&lt;li&gt;Terraform Atlantis&lt;/li&gt;
&lt;li&gt;Terragrunt&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;cicd-全自動化&#34;&gt;CI/CD 全自動化&lt;/h1&gt;
&lt;p&gt;當公司成功導入 terraform ，並且整合 Git-flow 的工作流程後，應該可以很明顯的感受到，整體的 infrastructure 產出穩定度有大幅提升，畢竟軟體工程中 code review 是穩定度的核心關鍵之一，而導入 terraform 與 infrastructure as code 讓 infrastructure 也能在合理的工作流程中被層層 review。&lt;/p&gt;
&lt;p&gt;stable master -&amp;gt; feature/add-new-infra -&amp;gt; PR feature/add-new-infra -&amp;gt; master&lt;/p&gt;
&lt;p&gt;feature branch merge 進去 master 之後，就確定是 review 過而且穩定的程式碼，再由工程師 pull 最新的 master ，然後在本地執行 terraform apply，把 infrastructure 生出來。&lt;/p&gt;
&lt;p&gt;這樣做本質不會有什麼大問題，畢竟 code 已經是穩定。然而，實務上卻還是會出現偶發的問題。例如：使用錯誤的 credentail 或 context，導致 dev 或 staging 的 infrastructure apply 到 prod 上，直接 p0 issue 大爆發，SRE 都跪著上班。又例如：使用錯誤的 master 版本 apply，結果也是服務掉線，整個 team 跪著上班。&lt;/p&gt;
&lt;p&gt;關鍵：團隊整體的安全性，是由程度最菜的同事決定。&lt;/p&gt;
&lt;p&gt;對我就是在說你XD。然而人都會菜，而人事成本也是公司經營的關鍵考量，相信所有同事都大神是不切實際的，不如改進工作流程，近一步降低人為操作失誤的可能。人的問題，根本之道還是教育，然而我們可以試著用技術與工具降低風險。&lt;/p&gt;
&lt;p&gt;以下的做法，可能會協助避免這個問題。我們要做的就是 CI/CD 的全自動化。&lt;/p&gt;
&lt;h1 id=&#34;需求&#34;&gt;需求&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;避免 apply 失誤
&lt;ul&gt;
&lt;li&gt;避免愚蠢的錯誤
&lt;ul&gt;
&lt;li&gt;環境切換錯誤&lt;/li&gt;
&lt;li&gt;apply 錯版本&lt;/li&gt;
&lt;li&gt;(愚蠢的錯誤比你想的要多，出現後會讓你三觀大開)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;加速工作流程
&lt;ul&gt;
&lt;li&gt;PR 結束後，在合適的時間自動 apply&lt;/li&gt;
&lt;li&gt;自動回報結果&lt;/li&gt;
&lt;li&gt;出錯自動 rollback 上個穩定版本&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;最小權限原則 (least privilege access)
&lt;ul&gt;
&lt;li&gt;原本工程師為了 apply ，會有 admin 權限的 credential&lt;/li&gt;
&lt;li&gt;移轉到安全的 CI/CD server 上，在 server 上執行&lt;/li&gt;
&lt;li&gt;工程師不再握有這些超級管理員權限，避免工作機被駭的安全隱憂
&lt;ul&gt;
&lt;li&gt;NOTE: 工程師被釣魚 (phishing) 或是社交工程攻擊 (social engineering attacks) 才是導致公司服務被害的主因，不可不防&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;解決方案&#34;&gt;解決方案&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;選擇安全的 CI/CD server，例如在內網的 self-hosted Jenkins server&lt;/li&gt;
&lt;li&gt;將 terraform 的執行點，從工程師本機移轉到 CI/CD 服務器上&lt;/li&gt;
&lt;li&gt;更改 CI/CD ，執行以下步驟
&lt;ul&gt;
&lt;li&gt;Terraform validate&lt;/li&gt;
&lt;li&gt;Terraform plan 的結果輸出到 Github / Slack&lt;/li&gt;
&lt;li&gt;plan 結束後停住 CI/CD，發送一個 apply request 到 Github comment，不再繼續執行 apply&lt;/li&gt;
&lt;li&gt;SRE 主管只要透過 Github comment 或是 Slack bot 就可以選擇合適的時間，approve apply&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;最後移除大多數工程師的 terraform 權限&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;範例&#34;&gt;範例&lt;/h1&gt;
&lt;p&gt;事實上，不同家的 CI/CD server，工作流程都是類似&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;checkout&lt;/li&gt;
&lt;li&gt;initialize tools / SDK (ex. az/aws/gcloud client)&lt;/li&gt;
&lt;li&gt;inject public cloud credential (ex. Azure/AWS/GCP key)&lt;/li&gt;
&lt;li&gt;terraform validete&lt;/li&gt;
&lt;li&gt;terraform plan&lt;/li&gt;
&lt;li&gt;terraform apply
&lt;ul&gt;
&lt;li&gt;(option) require manual approve&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果是 Jenkins 的使用者，可以參考 &lt;a href=&#34;https://github.com/Azure/terraform-with-jenkins-samples/blob/master/jenkins-pipelines/create-vmss-from-image/provision/Jenkinsfile&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Azure 提供的範例&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;環境管理&#34;&gt;環境管理&lt;/h1&gt;
&lt;p&gt;在人工 apply 的工作流程中，工程師需要自行切換環境，例如 git repo 工作目錄如下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;tree
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;project
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; ├── dev
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; ├── staging
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; └── prod
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cd project/dev; terraform plan  # plan staging
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cd project/prod; terraform plan # plan prod
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;這是相對比較安全的做法，在對的資料夾目錄下，就會 apply 到正確的環境，程式碼與環境有緊密的對映。除了以下幾種情形&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;想要部署 dev，結果沒注意到自己在 staging 或是 prod&lt;/li&gt;
&lt;li&gt;有一部分的 input variable 會影響結果，然後又輸入錯誤的 input 到錯誤的環境上&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;對很愚蠢，但我都見過（氣血攻心）。&lt;/p&gt;
&lt;p&gt;既然導入了自動化，環境的切換可以自動切換，例如&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有 feature branch 執行 CI/CD server 上的本地測試
&lt;ul&gt;
&lt;li&gt;lint&lt;/li&gt;
&lt;li&gt;init&lt;/li&gt;
&lt;li&gt;validate&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;所有 PR 都會觸發新的 dev 環境部署
&lt;ul&gt;
&lt;li&gt;plan&lt;/li&gt;
&lt;li&gt;apply&lt;/li&gt;
&lt;li&gt;測試腳本&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;所有 master merge / push 都會觸發 staginge 部署
&lt;ul&gt;
&lt;li&gt;QA 測試&lt;/li&gt;
&lt;li&gt;壓力測試&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;(optional) 所有 release candidate tag 會部署到 release candinate
&lt;ul&gt;
&lt;li&gt;release management&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;所有發布版本的 tag (ex. 1.1.0 / 1.2.0-release) 會部署 prod
&lt;ul&gt;
&lt;li&gt;當然要事先通知相關人士 stack holders&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;資深工程師只要控制 branch / tag 就可以控制發布。&lt;/p&gt;
&lt;p&gt;你說這樣，萬一天兵去自己打 tag 打錯 commit，或是推錯 branch 推到 master或是 release candidate，還不是依樣爆掉。那你可以把 master 與 release branch 鎖起來 (protected branch) ，然後把 tag push 權限鎖住。&lt;/p&gt;
&lt;p&gt;你說還是錯
那我&amp;hellip;
&amp;hellip;們看下一段 orz&lt;/p&gt;
&lt;h1 id=&#34;安全性&#34;&gt;安全性&lt;/h1&gt;
&lt;p&gt;雖然說是自動化改善工作流程，然而收回存取權限，對於服務的整體安全性大幅提升，畢竟是可以更改 infrastructure 的管理員帳戶。Terraform 既然能夠新增修改雲端的 infrastructure，這個帳號的權限是相當大的，萬一金鑰(GCP/AWS/Azure credentail) 流出或遭駭，後果都是毀滅性的，例如可以直接刪除服務的 infrastructure，或是修改防火牆的規則，偷埋其他金耀，&amp;hellip;等於是整座公有雲送給駭客。所以我們使用 Terraform 應該要慎重考慮存取權限的安全性。&lt;/p&gt;
&lt;p&gt;本來是每個 SRE 的本機電腦上，可能都會有這把帳戶權限。&lt;/p&gt;
&lt;p&gt;如果是 self-hosted Jenkins server，或是 Github enterprise server，把服務權限移轉到這些服務器，便可以確保金鑰永遠都在公司的防火牆內部網路，更加大幅度的提升整體的安全性。&lt;/p&gt;
&lt;h1 id=&#34;其他&#34;&gt;其他&lt;/h1&gt;
&lt;p&gt;可以進一步做金鑰權限分割，將底下四個權限透過公有雲的 IAM role 去切割。要是萬一金鑰還是外洩了，可以降低損失。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;讀取&lt;/li&gt;
&lt;li&gt;新增&lt;/li&gt;
&lt;li&gt;修改&lt;/li&gt;
&lt;li&gt;刪除&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你說這個不用自動化就可以做，我說如果分割金鑰然後人工自己切換操作，反而會增加操作的複雜度，增加錯誤的機會。然後工程師的痛苦程度，與手上的金鑰數量成正比。&lt;/p&gt;
&lt;p&gt;或是利用環境存取金耀分割，把金耀進一步切割成不同的權限，萬一掉了，損害也控制在一個環境之內。例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dev&lt;/li&gt;
&lt;li&gt;staging&lt;/li&gt;
&lt;li&gt;prod&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不同環境的 infrastructure ，在創建初期就是透過不同的帳號產生的，彼此不會有不乾淨殘留的帳號權限。&lt;/p&gt;
&lt;h1 id=&#34;小結&#34;&gt;小結&lt;/h1&gt;
&lt;p&gt;這邊就講兩件事&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自動化可以防呆&lt;/li&gt;
&lt;li&gt;自動化可以增加安全&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;參考文件&#34;&gt;參考文件&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://learn.hashicorp.com/tutorials/terraform/automate-terraform?in=terraform/automation&amp;amp;utm_source=WEBSITE&amp;amp;utm_medium=WEB_IO&amp;amp;utm_offer=ARTICLE_PAGE&amp;amp;utm_content=DOCS&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Terraform Official doc: Running Terraform in Automation
&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Terraform Infrastructure as Code: Example repository</title>
      <link>https://chechia.net/en/post/2020-10-02-terraform-infrastructure-as-code-repository-example/</link>
      <pubDate>Fri, 02 Oct 2020 11:15:48 +0800</pubDate>
      <guid>https://chechia.net/en/post/2020-10-02-terraform-infrastructure-as-code-repository-example/</guid>
      <description>&lt;p&gt;This article is part of &lt;a href=&#34;https://chechia.net/en/post/2020-06-14-terraform-infrastructure-as-code/&#34;&gt;從零開始的 Infrastructu as Code: Terraform&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/chechiachang/terraform-playground&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Get-started examples / SOP on Github&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://chechia.net/en/post/2020-06-15-terraform-infrastructure-as-code-transcript/&#34;&gt;Introducation to Terraform Iac: Speaker transcript&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://slides.com/chechiachang/terraform-introduction/edit&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Presentation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Check my website &lt;a href=&#34;https://chechia.net&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;chechia.net&lt;/a&gt; for other blog. &lt;a href=&#34;https://www.facebook.com/engineer.from.scratch&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Follow my page to get notification&lt;/a&gt;. Like my page if you really like it :)&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;上面講了很多 terraform 的操作範例，應該看到這裡，對於 terraform 基本上是什麼東西，應該有些概念了。然而這樣還不能算是學會 terraform，這種工具的東西一定要有實際操作過的經驗才算是學會。&lt;/p&gt;
&lt;p&gt;可以直接參考 Terraform 官方的 Get-started 文件來操作學習，我這邊也提供一個 Git repository 讓大家上手，當作初次操作的框架。&lt;/p&gt;
&lt;h3 id=&#34;提供做為範例的原始碼&#34;&gt;提供做為範例的原始碼&lt;/h3&gt;
&lt;p&gt;這個 Github Repository 是我給社群演講所使用的範例，第一次使用的可以參考&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/chechiachang/terraform-playground&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/chechiachang/terraform-playground&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;tree
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;├── README.md
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;├── SOP.md
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;├── aws/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;├── azure/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;└── gcp/
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;tldr&#34;&gt;TL;DR&lt;/h3&gt;
&lt;p&gt;選擇使用的雲平台，這邊提供三家範例，例如我這邊使用 gcp，當然你就要準備 GCP 的帳號，並且下載有執行權限的用戶 credential json key 等等。&lt;/p&gt;
&lt;p&gt;雖然我沒收 gcp 錢，這邊還是推廣一下 gcp 的 free credit 試用。阿要用 Azure Cloud 的 free credit 來執行這個範例也是完全沒問題，非常夠用。唯有 AWS 的試用方案跟剩下兩家不太一樣，這個 repository 起的服務可能會超過 AWS 的免費額度涵蓋範圍，總之請自己注意。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git clone https://github.com/chechiachang/terraform-playground
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cd gcp
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;DIR=my-new-project make project
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cd my-new-project
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;vim *tf
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;terraform init
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;terraform plan
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;terraform apply
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;這樣應該就會跑完。然後我們講解幾個地方。&lt;/p&gt;
&lt;h3 id=&#34;工作目錄&#34;&gt;工作目錄&lt;/h3&gt;
&lt;p&gt;Terraform 預設是以當下執行的目錄作為基準，掃描資料夾中的 .tf 檔案。所以可以把一個一個獨立的專案先用資料夾裝好，彼此內容互不干涉。&lt;/p&gt;
&lt;p&gt;我們這邊創建新的 subdirectory，這邊是以 my-new-project 為範例。這邊指的 project 只是一個 terraform resource 範圍，可以但不用是一個真實的 gcp project。terraform 執行是以一個 directory 為範圍，不同 project directory 可以透過不同 terraform 指令控制。如果是獨立的服務希望獨立管理也可以切開。&lt;/p&gt;
&lt;p&gt;我寫了一個簡單的 Makefile，進一步封裝基本的指令，基本上不需要 Makefile 以外的操作。
make project 是其中一個指令，幫忙創建資料夾、布置 Makefile 與基本的 terraform 設定等等。&lt;/p&gt;
&lt;p&gt;如果團隊有多人協作，非常推薦使用統一 Makefile / 或是 bash script 封裝，統一這些編輯的雜事，降低不同人編輯出錯的風險。&lt;/p&gt;
&lt;h3 id=&#34;目錄結構&#34;&gt;目錄結構&lt;/h3&gt;
&lt;p&gt;總之我們現在 cd 到 my-new-project 的工作目錄下，這個目錄代表一個專案。其他的 gke-playgound 與 national-team-5g 也是其他的專案，先忽略他。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;gcp
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;├── README.md
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;├── Makefile
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;├── my-new-project/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;├── gke-playground/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;├── national-team-5g/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;├── templates/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;└── modules/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cd my-new-project
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;進入 my-new-project 下，可以看到裡面已經有一些檔案，我們首先要編輯的是這個 &lt;code&gt;terraform.tf&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;my-new-project
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;├── Makefile
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;├── provider.tf
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;├── terraform.tf
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;└── variables.tf
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;vim terraform.tf
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;terraformtf-是-terraform-本身的設定&#34;&gt;terraform.tf 是 terraform 本身的設定&lt;/h3&gt;
&lt;p&gt;這邊是 Terraform Backend 的設定，如果不知道什麼是 terraform backend 這個我們明天的文章會講。這邊使用的 backend 是 terraform 官方自家的 &lt;a href=&#34;https://app.terraform.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;terraform cloud&lt;/a&gt;，可以在網站上&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;註冊使用者，填到底下 &lt;code&gt;organization&lt;/code&gt; 這裡&lt;/li&gt;
&lt;li&gt;創建一個 workspace，填到 &lt;code&gt;workspace.name&lt;/code&gt; 這裡&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;terraform {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  # Create a remote organization on https://app.terraform.io
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  backend &amp;#34;remote&amp;#34; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    # Provide terraform credential by
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    # - terraform login (suggested)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    # - use User API Token
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    #token        = &amp;#34;&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    hostname     = &amp;#34;app.terraform.io&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    organization = &amp;#34;chechia&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    workspaces {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      name = &amp;#34;terraform-playground&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;providertf-是-provider-的設定&#34;&gt;provider.tf 是 provider 的設定&lt;/h3&gt;
&lt;p&gt;terraform client 會把 tf 檔案拿來運算，透過 Provider ，將需求實際轉化成 API call ，然後送到公有雲或是其他目標。這邊就只講到這樣。&lt;/p&gt;
&lt;p&gt;provider 為了工作，可能會需要提供一些參數，例如 google 的 provider 會需要在這裡提供 credential_json 的路徑，請把它放在適合的地方，然後用絕對路徑指向 google&lt;/p&gt;
&lt;p&gt;NOTE: 不要 commit credential key 到 git repository 裡面。可以放到外層資料夾，或至少要 gitignore 掉。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;provider &amp;#34;google&amp;#34; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  version = &amp;#34;~&amp;gt;v3.25.0&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  credentials = file(var.credential_json)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  project = var.project
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  region  = var.region
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;variabletf-做參數的存放點&#34;&gt;variable.tf 做參數的存放點&lt;/h3&gt;
&lt;p&gt;雖然上面 tf 檔案使用了 terraform / provider / variable ，但 terraform 掃描檔案時，檔名本身並不會影響。也就是說，參數你想擺哪就擺哪。不過上面是常見的命名慣例，這樣擺人類比較容易找得到。&lt;/p&gt;
&lt;p&gt;variable 這邊設定的參數，比較像是 arguments，也就是當其他位置的 tf 檔案，引用這個資料夾作為 module 的時候，作為參數輸入的 placeholder，其他 tf 檔案可以使用 variable 關鍵字定義的參數，例如: var.project，或是 provider.tf 裡的 var.credential_json。&lt;/p&gt;
&lt;p&gt;variable 關鍵字也可以定義 default 預設值，如果沒有定義 default，也沒有從外部傳入 argument，會在 validate 時造成 error。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;# Global
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;variable &amp;#34;project&amp;#34; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  type    = string
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  default = &amp;#34;myproject&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;variable &amp;#34;credential_json&amp;#34; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  type    = string
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  default = &amp;#34;../credentials/gke-playground-0423-aacf6a39cc3f.json&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;variable &amp;#34;region&amp;#34; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  type    = string
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  default = &amp;#34;asia-east1&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;create&#34;&gt;Create&lt;/h3&gt;
&lt;p&gt;這裡我們試著創建一台 GCE，使用下列指令，會發現多了一個檔案 compute_instance.tf。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NAME=my-new-gce make gce
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;my-new-project
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;├── Makefile
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;├── compute_instance.tf
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;├── provider.tf
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;├── terraform.tf
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;└── variables.tf
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;內容大概是&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-v&#34; data-lang=&#34;v&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;my-new-gce&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nv&#34;&gt;source&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;../modules/compute_instance&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nv&#34;&gt;providers&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nv&#34;&gt;google&lt;/span&gt;      &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;google&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nv&#34;&gt;project&lt;/span&gt;      &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;var&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;project&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nv&#34;&gt;name&lt;/span&gt;         &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;my-new-gce&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nv&#34;&gt;image&lt;/span&gt;        &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;https://www.googleapis.com/compute/v1/projects/centos-cloud/global/images/centos-7-v20200429&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nv&#34;&gt;machine_type&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;n1-standard-1&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nv&#34;&gt;network&lt;/span&gt;    &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;projects/&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;var&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;project&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;/global/networks/myproject&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nv&#34;&gt;subnetwork&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;projects/&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;var&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;project&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;/regions/asia-east1/subnetworks/myproject&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;module 關鍵字定義一組資源，&lt;a href=&#34;https://github.com/chechiachang/terraform-playground/tree/master/gcp/modules/compute_instance&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;具體的內容是這裡&lt;/a&gt;，簡單來說可以把一堆 tf 檔案放在一塊，然後把需要的參數使用 variable.tf 拉出去，讓其他地方引用。&lt;/p&gt;
&lt;p&gt;source = &amp;quot;&amp;quot; 是實際引用的 module 來源&lt;/p&gt;
&lt;p&gt;底下是這個 module 需要用到的參數，例如 project, name, image, machine_type,&amp;hellip; 等是 gce 這個 module 需要的參數。&lt;/p&gt;
&lt;h3 id=&#34;makefile&#34;&gt;Makefile&lt;/h3&gt;
&lt;p&gt;NAME=my-new-gce make gce
這行指令與 terraform 無關，只是一個快速生成 compute_instance.tf 的小腳本。使用這個腳本可以&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;快速產生 tf 檔案&lt;/li&gt;
&lt;li&gt;產生標準化的 tf 檔案，所有 project 的 compute_instance 都長一樣&lt;/li&gt;
&lt;li&gt;抽換名子 name&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用 symbolic link 讓所有 project 資料夾使用同一個 Makefile，keep your code DRY。&lt;/p&gt;
&lt;p&gt;最後就是常規的 plan 與 apply，這邊沒有什麼特別的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;terraform plan
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;terraform apply
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;小結&#34;&gt;小結&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;有規律地整理 project 可以降低維護成本&lt;/li&gt;
&lt;li&gt;善用 module 封裝，可以提高整體的重用性與易用姓，提高開發效率&lt;/li&gt;
&lt;li&gt;使用 template tf 可以加速重複的資源產生步驟&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;問題: 此時的資料夾中還是充滿大量重複的 code，例如到處都需要 provider、重複的 module，一大堆重複的東西。有沒有可能再讓我們的程式碼更 DRY 一點呢?&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/gruntwork-io/terragrunt&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Terragrunt&lt;/a&gt; 幫我們實現這點，非常值得使用的工具。請見下篇分享。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Gcp Preemptible Instance Kubernetes</title>
      <link>https://chechia.net/en/post/2020-09-26-gcp-preemptible-instance-kubernetes/</link>
      <pubDate>Sat, 26 Sep 2020 17:24:20 +0800</pubDate>
      <guid>https://chechia.net/en/post/2020-09-26-gcp-preemptible-instance-kubernetes/</guid>
      <description>&lt;h3 id=&#34;先占虛擬機與-kubernetes&#34;&gt;先占虛擬機與 Kubernetes&lt;/h3&gt;
&lt;p&gt;在 GCP 使用先占虛擬機，會需要面對先占虛擬機的額外限制&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;資料中心會 (可預期或不可預期地) 終止先占虛擬機&lt;/li&gt;
&lt;li&gt;先占虛擬機不能自動重啟，而是會被資料中心終止後回收&lt;/li&gt;
&lt;li&gt;GCP 不保證有足夠的先占虛擬機&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;節點的終止會造成額外的維運成本，例如&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;管理多個節點，容忍先占虛擬機的移除，自動補充新的先占虛擬機&lt;/li&gt;
&lt;li&gt;管理多個應用複本，節點終止時，維護整體應用的可用性&lt;/li&gt;
&lt;li&gt;將移除節點上的應用，重新排程到其他可用節點&lt;/li&gt;
&lt;li&gt;動態維護應用複本的服務發現 (Service Discovery) 與服務端點 (Endpoints)
&lt;ul&gt;
&lt;li&gt;意思是應用關閉重啟後，換了一個新 IP，還要能持續存取應用。舊的 IP 要主動失效&lt;/li&gt;
&lt;li&gt;配合應用的健康檢查 (Health Check) 與可用檢查 (Readiness Check)，再分配網路流量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這些需求，必須要有自動化的管理工具，是不可能人工管理的，想像你手上使用 100 個先占節點，平均每天會有 10% - 15% 的先占節點被資料中心回收，維運需要&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;補足被移除的 15 個節點&lt;/li&gt;
&lt;li&gt;計算被移除的應用，補足移除的應用數量&lt;/li&gt;
&lt;li&gt;移除失效的應用端點，補上新的應用端點&lt;/li&gt;
&lt;li&gt;持續監控應用狀態&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;沒有自動化管理工具，看了心已累 (貓爪掩面)&lt;/p&gt;
&lt;p&gt;我們使用 Kubernetes 協助維運自動化，在 GCP 上我們使用 GKE，除了上述提到的容器應用管理自動化外，GKE 還額外整合先占虛擬機的使用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;啟用先占虛擬機的節點池 (node-pool)，設定節點池的自動拓展，自動補足先占節點的數量&lt;/li&gt;
&lt;li&gt;GKE 自動維護先占虛擬機的 labels&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;關於 GKE 的先占虛擬機的完整細節，請見&lt;a href=&#34;https://cloud.google.com/kubernetes-engine/docs/how-to/preemptible-vms&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GCP 官方文件&lt;/a&gt;。這份文件底下也提供了 GCP 官方建議的先占虛擬機最佳實踐&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;架構設計需要假設，部分或是全部的先占虛擬機都不可用的情形&lt;/li&gt;
&lt;li&gt;Pod 不一定有時間能優雅終止 (graceful shutdown)&lt;/li&gt;
&lt;li&gt;同時使用隨選虛擬機與先占虛擬機，以維持先占虛擬機不可用時，服務依然可用&lt;/li&gt;
&lt;li&gt;注意節點替換時的 IP 變更&lt;/li&gt;
&lt;li&gt;避免使用有狀態的 Pod 在先占虛擬機上 (這點稍後的文章，我們會試圖超越)&lt;/li&gt;
&lt;li&gt;使用 node taint 來協助排程到先占虛擬機，與非先占虛擬機&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;總之，由於有容器自動化管理，我們才能輕易的使用先占虛擬機。&lt;/p&gt;
&lt;h3 id=&#34;gke&#34;&gt;GKE&lt;/h3&gt;
&lt;p&gt;然而，決定使用 GKE 後，就有許多關於成本的事情需要討論&lt;/p&gt;
&lt;p&gt;先看 &lt;a href=&#34;https://cloud.google.com/kubernetes-engine/pricing&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GKE 的計費方式 pricing&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每個 GKE 集群管理費用 $0.1/hr = $72/hr&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這個費用是固定收費，只要開一個集群，不論集群的節點數量。所以在節點多、算力大的集群裡，這個費用會被稀釋，但在節點少的集群裡比例會被放大。&lt;/p&gt;
&lt;p&gt;然後 GKE 還是會有一些自己的毛，俗話說有一好沒兩好，我們使用它的好處同時，也要注意許多眉眉角角。再來爬&lt;a href=&#34;https://cloud.google.com/kubernetes-engine/docs/concepts/cluster-architecture&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;文件&lt;/a&gt;。如同最前面宣導，用產品就要乖乖把文件看完，不過這裡先針對與先占虛擬機相關的議題&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://cloud.google.com/kubernetes-engine/docs/concepts/cluster-architecture#memory_cpu&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Allocatable Resource&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cloud.google.com/kubernetes-engine/docs/concepts/regional-clusters&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Regional Cluster&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cloud.google.com/kubernetes-engine/docs/concepts/cluster-autoscaler&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cluster autoscaler&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;allocatable-resource&#34;&gt;Allocatable Resource&lt;/h3&gt;
&lt;p&gt;在網路上看到這篇好文 &lt;a href=&#34;https://learnk8s.io/allocatable-resources&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GKE 上的可使用的資源 Allocatable Resource&lt;/a&gt;。啥意思呢？難道還有不能使用的資源嗎？&lt;/p&gt;
&lt;p&gt;沒錯，GKE 會保留一定的機器資源 (e.g. cpu, memory, disk)，來維持節點的管理元件，例如 container runtime (e.g. Docker)、kubelet、cAdvisor。&lt;/p&gt;
&lt;p&gt;也就是說，就算我們跟 GCP 購買了算力，有一個比例的資源我們是使用不到的。細節請見 &lt;a href=&#34;https://cloud.google.com/kubernetes-engine/docs/concepts/cluster-architecture#memory_cpu&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;理解 GKE 集群架構&lt;/a&gt;。這會影響我們單一節點的規格，我們也需要一並計算，能實際使用的資源 (allocatable resource)。&lt;/p&gt;
&lt;p&gt;Allocatable = Capacity - Reserved - Eviction Threshold&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Capacity，是機器上實際裝載的資源，例如 n1-standard-4 提供 4 cpu 15 Gb memory&lt;/li&gt;
&lt;li&gt;Reserved，公有雲代管集群，預保留的資源&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kubernetes.io/docs/tasks/administer-cluster/out-of-resource/#eviction-thresholds&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Eviction Threshold&lt;/a&gt;：Kubernetes 設定的 kubelet 驅逐門檻&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;驅逐門檻-eviction-threshold&#34;&gt;驅逐門檻 (Eviction threshold)&lt;/h3&gt;
&lt;p&gt;Kubelet 會主動監測節點上的資源使用狀況，當節點發生資源不足的狀況時，kubelet 會主動終止某些 Pod 的運行，並回收節點的資源，來避免整個節點資源不足導致的系統不穩定。被終止的 Pod 可以再次排程到其他資源足夠的節點上。細節請見 &lt;a href=&#34;https://kubernetes.io/docs/concepts/scheduling-eviction/eviction-policy/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;官方文件 Scheduling and Eviction&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在 Kubernetes 上，我們可以進一步設定驅逐門檻，當節點的可用資源低於驅逐的門檻，kubelet 會觸發 Pod 驅逐機制&lt;/p&gt;
&lt;p&gt;GKE 上每個節點會額外保留 100 MiB 的記憶體，作為驅逐門檻，意思是當節點耗盡資源，導致剩餘記憶體低於 100 MiB 的時候，會直接觸發 GKE 的 Pod Eviction，終止並回收部分的 Pod。換句話說，這 100 MiB 是不能被使用的資源。細節請見&lt;a href=&#34;https://cloud.google.com/kubernetes-engine/docs/concepts/cluster-architecture#eviction_threshold&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;官方文件&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;集群保留資源精算&#34;&gt;集群保留資源精算&lt;/h3&gt;
&lt;p&gt;資源的定義，使用雲平台的一般費用大多來自此&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;cpu&lt;/li&gt;
&lt;li&gt;memory&lt;/li&gt;
&lt;li&gt;storage&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然後是這個表，注意保留的資源是累進級距&lt;/p&gt;
&lt;p&gt;255 MiB of memory for machines with less than 1 GB of memory
25% of the first 4GB of memory
20% of the next 4GB of memory (up to 8GB)
10% of the next 8GB of memory (up to 16GB)
6% of the next 112GB of memory (up to 128GB)
2% of any memory above 128GB&lt;/p&gt;
&lt;p&gt;值計上能夠用到的資源，底下 GCP 也整理好了，例如 n1-standard-4 實際使用的是 memory 12.3/15，cpu 3.92/4。&lt;/p&gt;
&lt;p&gt;在維持合理的使用率下，開啟大的機器，可以降低被保留的資源比例，依照筆者公司過去經驗，GKE 起跳就是 n1-standard-4 或是以上規格，如果低於這個規格，可調度的資源比例真的太低，應該重新考慮一下這個解決方案是否合乎成本。&lt;/p&gt;
&lt;p&gt;但究竟什麼規格的機器適合我們的需求，說實在完全要看執行的應用而定。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Gcp Preemptible Instance Introduction</title>
      <link>https://chechia.net/en/post/2020-09-26-gcp-preemptible-instance-introduction/</link>
      <pubDate>Sat, 26 Sep 2020 11:03:40 +0800</pubDate>
      <guid>https://chechia.net/en/post/2020-09-26-gcp-preemptible-instance-introduction/</guid>
      <description>&lt;h1 id=&#34;先占虛擬機技術文件二三事&#34;&gt;先占虛擬機，技術文件二三事&lt;/h1&gt;
&lt;p&gt;第一篇的內容大部份還是翻譯跟講解官方文件。後面幾篇才會有實際的需求與解決方案分析。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://cloud.google.com/compute/docs/instances/preemptible&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Google 先占虛擬機官方文件&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用不熟悉的產品前一定要好好看文件，才不會踩到雷的時候，發現人家就是這樣設計的，而且文件上寫得清清楚楚。以為是 bug 結果真的是 feature，雷到自己。先占虛擬機是用起來跟普通虛擬機沒什麼兩樣，但實際上超級多細節要注意，毛很多的產品，請務必要小心使用。&lt;/p&gt;
&lt;p&gt;以下文章是筆者工作經驗，覺得好用、確實有幫助公司，來跟大家分享。礙於篇幅，這裡只能非常粗略地描述我們團隊思考過的問題，實際上的問題會複雜非常多。文章只是作個發想，並不足以支撐實際的業務，所以如果要考慮導入，還是要&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;多作功課，仔細查閱官方文件，理解服務的規格&lt;/li&gt;
&lt;li&gt;深入分析自身的需求&lt;/li&gt;
&lt;li&gt;基於上面兩者，量化分析&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;什麼是先占虛擬機器preemptible-instance&#34;&gt;什麼是先占虛擬機器(Preemptible Instance)&lt;/h1&gt;
&lt;p&gt;先占虛擬機器，是資料中心的多餘算力，讀者可以想像是目前賣剩的機器，會依據資料中心的需求動態調整，例如&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;目前資料中心的算力需求低，可使用的先占虛擬機釋出量多，可能可以用更便宜的價格使用&lt;/li&gt;
&lt;li&gt;目前資料中心算力需求高，資料中心會收回部分先占虛擬機的額度，轉化成隨選付費的虛擬機 (pay-as-you-go)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由於先占虛擬機會不定時（但可預期）地被資料中心收回，因此上頭執行的應用，需要可以承受機器的終止，適合有容錯機制 (fault-tolerant) 的應用，或是批次執行的工作也很適合。&lt;/p&gt;
&lt;h1 id=&#34;先占機器的優缺點&#34;&gt;先占機器的優缺點&lt;/h1&gt;
&lt;p&gt;除了有一般隨選虛擬機的特性，先占虛擬機還有以下特點&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比一般的虛擬機器便宜非常多，這也是我們選用先占虛擬機優於一般虛擬機的唯一理由&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;先占虛擬機有以下限制，以維運的角度，這些都是需要考量的點。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GCP 不保證會有足夠的先占虛擬機&lt;/li&gt;
&lt;li&gt;先占虛擬機不能直接轉換成普通虛擬機&lt;/li&gt;
&lt;li&gt;資料中心觸發維護事件時(ex. 回收先占虛擬機)，先占虛擬機不能設定自動重啟，而是會直接關閉&lt;/li&gt;
&lt;li&gt;先占機器排除在 &lt;a href=&#34;https://cloud.google.com/compute/sla&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GCP 的服務等級協議 (SLA)&lt;/a&gt;之外&lt;/li&gt;
&lt;li&gt;先占虛擬機不適用&lt;a href=&#34;https://cloud.google.com/free&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GCP 免費額度&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;費用粗估試算&#34;&gt;費用粗估試算&lt;/h1&gt;
&lt;p&gt;至於便宜是多便宜呢？這邊先開幾個例子給各位一些概念。&lt;/p&gt;
&lt;p&gt;以常用的 N1 standard 虛擬機：https://cloud.google.com/compute/vm-instance-pricing#n1_standard_machine_types&lt;/p&gt;
&lt;p&gt;Hourly
Machine type	CPUs	Memory	Price (USD)	Preemptible price (USD)
n1-standard-1	1	3.75GB	$0.0550		$0.0110
n1-standard-2	2	7.5GB	$0.1100		$0.0220
n1-standard-4	4	15GB	$0.2200		$0.0440
n1-standard-8	8	30GB	$0.4400		$0.0880
n1-standard-16	16	60GB	$0.8800		$0.1760
n1-standard-32	32	120GB	$1.7600		$0.3520
n1-standard-64	64	240GB	$3.5200		$0.7040&lt;/p&gt;
&lt;p&gt;如果是用 GPU 運算：https://cloud.google.com/compute/gpus-pricing&lt;/p&gt;
&lt;p&gt;Model			GPUs	GPU memory	GPU price (USD)	Preemptible GPU price (USD)
NVIDIA® Tesla® T4	1 GPU	16 GB GDDR6	$0.35 per GPU	$0.11 per GPU
NVIDIA® Tesla® V100	1 GPU	16 GB HBM2	$2.48 per GPU	$0.74 per GPU&lt;/p&gt;
&lt;p&gt;依據虛擬機規格的不同，先占虛擬機大約是隨選虛擬機價格的 2 到 3 折。在 AWS 與 Azure，由於計費方式不同，有可能拿到 1 折左右的浮動價格。從各種角度來說，都是非常高的折數。&lt;/p&gt;
&lt;p&gt;不妨說，這整系列文章，都是衝這著個折數來的 XD。畢竟成本是實實在在的花費，工作負載 (workload) 合適的話，應該盡量嘗試導入。&lt;/p&gt;
&lt;p&gt;這個折數還有另外一個效果是，可以在相同成本下，添增更多資源算力，作為解決方案。什麼意思呢？就是如果工作負載合適的話，可以使用更高規格的先占節點，整體成本反而會下降。&lt;/p&gt;
&lt;p&gt;至於究竟差多少，需要依據規格與定價詳細試算才知道。底下我們就來算算看。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Gcp Preemptible Instance Resource Calculation</title>
      <link>https://chechia.net/en/post/2020-09-25-gcp-preemptible-instance-resource-calculation/</link>
      <pubDate>Fri, 25 Sep 2020 12:22:02 +0800</pubDate>
      <guid>https://chechia.net/en/post/2020-09-25-gcp-preemptible-instance-resource-calculation/</guid>
      <description>&lt;h3 id=&#34;關於資源評估&#34;&gt;關於資源評估&lt;/h3&gt;
&lt;p&gt;架構團隊提供虛擬機給應用，有個問題時常出現：應該分配多少資源給應用？例如：後端準備一個 API server，SRE 這邊要準備多少什麼規格的機器？&lt;/p&gt;
&lt;p&gt;以往使用虛擬機直接部署應用時，會需要明確規劃各群虛擬機，各自需要執行的應用，如果沒有做資源的事前評估，有可能放上機器運行後就發生資源不足。&lt;/p&gt;
&lt;p&gt;導入 Kubernetes 後，透過節點池 (Node Pool) 形成一個大型資源池，設定部署的政策後，讓 Kubernetes 自動調度應用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每一個節點的資源夠大，使得應用虛擬機器上所佔的比例相對較小，也就是單一應用的調度不會影響節點的整體負載
&lt;ul&gt;
&lt;li&gt;如果節點太小，調度應用就會有些侷促，例如：一個 API server 均載時消耗 1 cpu 滿載時消耗 2 cpu。準備 3 cpu 的虛擬機，調度應用時幾乎是遷移整台虛擬機的負載&lt;/li&gt;
&lt;li&gt;此外還有機會因為&lt;a href=&#34;&#34;&gt;上篇&lt;/a&gt;提到的資源保留，造成調度失敗。如果準備 24 cpu 的機器，調度起來彈性就很大，對節點的性能衝擊也比較低&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;只需要估計整體的資源消耗率計算需求，配合自動擴展，動態器補足不足的資源
&lt;ul&gt;
&lt;li&gt;例如：估計總共需要 32 cpu ，準備 36 cpu 的虛擬機，當滿載時依據 cpu 壓力自動擴容到 48 cpu&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;希望整體資源的使用率夠高，當然預留太多的資源會造成浪費&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要控管 Kubernetes 的資源使用量也可設定&lt;a href=&#34;https://kubernetes.io/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;資源需求與資源限制&lt;/a&gt;，延伸閱讀。&lt;/p&gt;
&lt;p&gt;估計得越準確，當然實際部署的資源掌握度就越高，然而筆者過去的經驗，團隊在交付源碼時未必就能夠做出有效的資源消耗評估，那有沒有什麼辦法可以幫助我們？&lt;/p&gt;
&lt;h3 id=&#34;資源需求估估看&#34;&gt;資源需求估估看&lt;/h3&gt;
&lt;p&gt;如果應用開發團隊，有先作應用的 profiling，然後 release candidate 版本有在 staging 上作壓力測試的話，維運團隊這邊應該就取得的數據，做部署前的資源評估。&lt;/p&gt;
&lt;p&gt;應用在不同狀態或是工作階段，會消耗不同的資源&lt;/p&gt;
&lt;p&gt;例如：運算密集的 batch job 可能會有&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;控制節點 (master node) 啟動後會佔有一定的資源，一般來說不會消耗太多，只是需要為控制節點優先保留資源&lt;/li&gt;
&lt;li&gt;工作節點 (worker node) 啟動時會需要預留足夠的資源，接收工作後會逐漸增加資源使用，拉到滿載&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如：面向用戶的服務，可能會有&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;啟動應用所需的資源&lt;/li&gt;
&lt;li&gt;沒有大量請求，只維持基本應用運行所使用的資源&lt;/li&gt;
&lt;li&gt;負載壓力灌進來時，消耗資源隨用戶請求數量的成長曲線，設定的安全上界&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果沒有這些數據，其實維運很難事前估計資源，變成要實際推上線後見招拆招，基於實際的資源消耗去做自動擴容，其實有可能會造成資源的浪費，因此我建議如果開發團隊沒有作 profiling，維運團隊可以在工作流程內簡單加一步 profiling，目前主流語言都有提供相關工具，簡單的執行就可以獲得很多資訊。&lt;/p&gt;
&lt;p&gt;至於壓力測試，也是可以使用基本的工具(例如 &lt;a href=&#34;https://artillery.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Artilery&lt;/a&gt;)簡單整到工作流程。特別是面對客戶的應用，務必要進行壓力測試。&lt;/p&gt;
&lt;p&gt;有了上述的資源需求數據，才能事先安排機器的規格。例如&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;應用是面對客戶的 API server&lt;/li&gt;
&lt;li&gt;基本資源是 200m cpu 1Gi memory，這部分直接寫進 Kubernetes resource request，在排程時就先結點上預留。&lt;/li&gt;
&lt;li&gt;負載拉到 1,000 RPS，latency 95% 20ms  99% 30ms，這時的資源需求的上界大約 2 cpu 4 Gi memory&lt;/li&gt;
&lt;li&gt;超過 1,000 RPS 就應該要透過水平擴展去增加更多 instamce&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果單跑這個 API server，就可以安排 memory 8，cpu 4 的 GKE node-pool，讓負載落在可用資源的 60%-70%，這樣還有餘裕可以承受大流量，給自動水平擴展做動的時間。&lt;/p&gt;
&lt;h3 id=&#34;資源調整參考&#34;&gt;資源調整參考&lt;/h3&gt;
&lt;p&gt;當然這些數據都可以依照時實際需求調整，資源要壓縮得更緊或更鬆都是可行的。&lt;/p&gt;
&lt;p&gt;如果應用有整合分析後台，例如 Real-time Uer Monitoring、或是基本的 Google Analytics，都可以觀察這些調整實際對用戶帶來的影響，用戶行為改變對公司營收的影響，全都可以量化。例如&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;機器負載拉到 80%，cpu 的壓力，導致 API latency 增加到 95% 50ms 99% 100ms&lt;/li&gt;
&lt;li&gt;此時用戶已經很有感了，會導致 0.1% 用戶跳轉離開&lt;/li&gt;
&lt;li&gt;而這 0.1% 的用戶，以往的平均消費，換算成為公司營收，是 $1,000/month&lt;/li&gt;
&lt;li&gt;把機器負載壓到 60%，只計算 cpu 的數量的話，需要多開 3 台 n1-standard-4 機器，共計 $337.26/month&lt;/li&gt;
&lt;li&gt;提供老闆做參考，老闆可能會趨向加開機器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;當然上面的例子都非常簡化，變成國中數學問題，這邊只是提供一個估算的例子。現實中的問題都會複雜百倍，例如機器規格拉上去出現新的瓶頸、例如依賴的服務，message queue、database 壓力上升，或是公司內部問題，就拿不到預算(血淚 SRE)。如果要減少機器，也可以參考，一般來說聽到關機器省錢的話，老闆都會接受的 XD。&lt;/p&gt;
&lt;h3 id=&#34;回到先占機器&#34;&gt;回到先占機器&lt;/h3&gt;
&lt;p&gt;根據上面的國中數學，把應用一個一個都計算清楚，需求逐漸明確了。假設，架構團隊拿到開機器的工單，掐指一算，決定&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 GKE cluster&lt;/li&gt;
&lt;li&gt;6 n1-standard-4&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這些都是隨選虛擬機，價格大約是 $747/month (含集群管理費 $73/month)。今天有人腦動大開，那如果全部換成先占節點呢？變成 $265/month，虛擬機費用 $192 / $674 = 0.28 直接打超過三折。&lt;/p&gt;
&lt;p&gt;有人就擔心，這樣真的可以嗎？真的沒問題嗎？會不會影響用戶阿。&lt;/p&gt;
&lt;p&gt;答案是會，就是會影響用戶 XD&lt;/p&gt;
&lt;p&gt;聽到這邊很多人就怕了。但是怎麼個影響法呢，還需要看底下幾個段落，如果換成先占虛擬機，用戶會怎麼受到影響。我們也要試圖量化這個影響，當作要不要導入的判斷依據。&lt;/p&gt;
&lt;p&gt;句個反例，「我覺得可以」「你覺得不行」，或是「某某公司的某某團隊可以啊」「我們公司也來做吧」，這些都是很糟糕的理由。除了對內部毫無說服力之外，也沒有辦法作為導入成效的指標，會讓團隊陷入「導入了也不知道有比導入前好？」或是「具體導入後成效量化」，會影響團隊做出真正有效的判斷，應極力避免。&lt;/p&gt;
&lt;p&gt;此外，問行不行之前，其實需要知道團隊願意為了三折機器，付出多少成本。如果只是每月省個台幣 15,000，工程師薪水都超過了。但如果手下有三十台或三百台以上，也許就非常值得投資。成本不是絕對的，很多時候要與其他成本 (e.g. 開發人力時間成本) 一起考量。&lt;/p&gt;
&lt;p&gt;以上都是說明導入的動機，以下說明先占虛擬機的各種機制，以及對應用的實際影響。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Gcp Preemptible Instance Requirement</title>
      <link>https://chechia.net/en/post/2020-09-24-gcp-preemptible-instance-requirement/</link>
      <pubDate>Thu, 24 Sep 2020 13:39:12 +0800</pubDate>
      <guid>https://chechia.net/en/post/2020-09-24-gcp-preemptible-instance-requirement/</guid>
      <description>&lt;h1 id=&#34;需求規劃&#34;&gt;需求規劃&lt;/h1&gt;
&lt;p&gt;使用先占節點比起使用一般隨選虛擬機，會多出許多技術困難需要克服，只有節省下的成本大於整體技術成本時，我們才會選用先占節點。因此這邊要進行成本精算，重新調整的架構下，實際到底能省多少錢。務必使用 &lt;a href=&#34;https://cloud.google.com/products/calculator?hl=zh-tw&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Google Cloud Pricing Calculator&lt;/a&gt; 精算成本。&lt;/p&gt;
&lt;p&gt;另外，雖然先占虛擬機會有很多額外的限制與技術困難，但實務上還是要對比實際的需求，有些限制與需求是衝突的，有些限制則完全不會影響我們的需求。前者當然會帶給我們較高的導入難度，後者可能會非常輕鬆。&lt;/p&gt;
&lt;p&gt;這邊想給大家的概念是，務必先明確需求，再討論技術。這點很重要，技術的適用與否，不是由個人的喜好決定，唯一的判斷標準，是能不能有效率的滿足需求。&lt;/p&gt;
&lt;p&gt;所以這邊先定義我們以下幾個需求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;執行短期的 batch job&lt;/li&gt;
&lt;li&gt;執行長期的 user-facing API server&lt;/li&gt;
&lt;li&gt;執行長期的 stateful 資料庫、儲存庫&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;batch-job&#34;&gt;Batch Job&lt;/h3&gt;
&lt;p&gt;常見的範例，例如&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用網路爬蟲 (crawler) 去抓取許多網站的所有內容&lt;/li&gt;
&lt;li&gt;使用 GPU 進行機器學習的 Model Training&lt;/li&gt;
&lt;li&gt;大數據計算&lt;/li&gt;
&lt;li&gt;MapReduce&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這些任務的核心需求，很簡單直接&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;盡快完成整體工作&lt;/li&gt;
&lt;li&gt;盡可能節省大量算力成本&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如：我手上的機器學習 Model 粗略估計 10000 小時*GPU 的算力需求，才能產出一個有效的Model。由於大量的算力需求，一般來說都會選擇分散式的運算框架 (ex. MapReduce) ，將真正消耗算力的工作，使用分而化之 (divide and conquer) 的架構設計，將分配任務的控制節點 (master)，與實際進行運算的工作節點(worker) 拆分。基於原本的分散式架構，幾乎可以無痛地將工作節點轉移到先占虛擬機上。&lt;/p&gt;
&lt;p&gt;根據上述的需求，這類的工作特性可能有&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU / GPU 算力需求高的運算節點 (Worker)&lt;/li&gt;
&lt;li&gt;Worker 本身是無狀態的 Stateless&lt;/li&gt;
&lt;li&gt;可控的即時負載&lt;/li&gt;
&lt;li&gt;將整體工作切分成任務單元 (task)，分配給工作節點&lt;/li&gt;
&lt;li&gt;任務單元的狀態外部保留，工作節點可容錯 (fault-tolerent)，任務單元可復原&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由於先占虛擬機可能是浮動價格，這類工作可以根據優先程度，調整合適的工作時間，例如在資料中心算力需求低，先占虛擬機的費用低廉時，啟用較多的工作節點加快運算，如果費用高時，可以降低先占虛擬機的使用，延後工作，甚至是調用不同區域，費用低的工作節點，來降低整體的成本。&lt;/p&gt;
&lt;p&gt;執得注意的是，這類任務的控制節點 (master)，也許是集中式的，也許是分散式的，需要根據性質考量，是否適合放在先占虛擬機上。有些架構控制節點可以容錯，然而錯誤發生後會需要復原狀態，這時會消耗額外的算力，可能會拖緩整體進度，造成算力的消耗。也許就可以考量使用隨選虛擬機配合使用。&lt;/p&gt;
&lt;h3 id=&#34;user-facing-services&#34;&gt;User-facing services&lt;/h3&gt;
&lt;p&gt;常見的範例，例如&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Restful API server&lt;/li&gt;
&lt;li&gt;Websocket Server&lt;/li&gt;
&lt;li&gt;TCP/HTTP reverse proxy&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這些工作的核心需求如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;整題服務的高可用性 (high availability)&lt;/li&gt;
&lt;li&gt;承受不可預期的負載高峰 (load spikes)&lt;/li&gt;
&lt;li&gt;整體表現需要低延遲 (low latency)&lt;/li&gt;
&lt;li&gt;可以水平擴展 (horizontal scaling)，支撐用戶的成長&lt;/li&gt;
&lt;li&gt;最終平衡效能呈現與成本&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由於會面對使用者，需要能支持使用者的壓力，又同時需要有一定的服務效能，來維持使用者體驗。實務上設計可能採用無狀態應用 (stateless)，多副本 (replica) 部署到集群中。需要儲存的狀態（如用戶狀態），使用外部的共用儲存 (例如：Redis，RDBMS，或是 Non-SQL DB)。請求的流量，透過上游的負載均衡器 (Load Balancer)，送進多個後端，處理完成請求後，再返回給使用者。&lt;/p&gt;
&lt;p&gt;這樣的設計，使用先占虛擬機也不會有太多的問題&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;現代的附載均衡器多半都能像後端做可用性檢測 (health check)，可以把流量導向工作正常的節點，如果後端的虛擬機被資料中心收回了，流量也會移轉到其他節點上，不會遺失用戶請求&lt;/li&gt;
&lt;li&gt;配合自動水平拓展工具 (Auto horizontal scaler)，可以設定期望的服務節點數量，如果資料中心回收先占節點，拓展工具可以同時去取得新的先占節點，或是取得隨選隨用的虛擬機&lt;/li&gt;
&lt;li&gt;配合流量監測，也可以動態調整期望的服務節點數量，例如：偵測到大量用戶連線數時，增加更多服務節點，待流量下降後，再降低服務節點數量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這樣的設計實務上有幾點注意&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;雖然說應用後端本身是無狀態的，但面對用戶也許還是會有部分狀態存在應用外部，例如：User session，或是 websocket 的長連線。特別注意這些服務斷線的時候，對於使用者的影響，配合前端增強使用者體驗&lt;/li&gt;
&lt;li&gt;後端水平拓展後，瓶頸會轉移到其他地方，例如 Database 成為效能瓶頸，應用這邊需要做一定程度的自律( ex. connection limit，rate limit)，避免不斷增長的應用壓垮依賴的服務，如 MessageQueue 或是 Database&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分散式的儲存中心 (distributed DB)，如：cassandra 或是小強 DB。而這樣類型的服務，是否適合放在先占節點上？&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Gcp Preemptible Instance Speficication</title>
      <link>https://chechia.net/en/post/2020-09-23-gcp-preemptible-instance-speficication/</link>
      <pubDate>Wed, 23 Sep 2020 16:23:14 +0800</pubDate>
      <guid>https://chechia.net/en/post/2020-09-23-gcp-preemptible-instance-speficication/</guid>
      <description>&lt;h1 id=&#34;先占虛擬機終止流程-preemption-process&#34;&gt;先占虛擬機終止流程 (Preemption process)&lt;/h1&gt;
&lt;p&gt;子曰：未知生焉知死。但做工程師要反過來，考量最差情形，也就是要知道應用可能如何死去。不知道應用可能怎麼死，別說你知道應用活得好好的，大概想表達這麼意思。&lt;/p&gt;
&lt;p&gt;這對先占虛擬機來說特別重要，一般應用面對的機器故障或是機器終止，在使用先占西你幾的狀況下，變成每日的必然，因此，需要對應用的終止情境，與終止流程有更精細的掌控。如同前幾篇所說的，先占虛擬機會被公有雲收回，但收回的時候不會突然機器就 ben 不見，會有一個固定的流程。&lt;/p&gt;
&lt;p&gt;如果你的應用已經帶有可容錯的機制，能夠承受機器突然變不見，服務還好好的，仍然要花時間理解這邊的流程，藉此精算每天虛擬機的終止與替換：應用會有什麼反應，會產生多少衝擊，稍後可以量化服務的影響。例如&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;應用重啟初始化時 cpu memory 突然拉高&lt;/li&gt;
&lt;li&gt;承受節點錯誤後的復原流程，需要消耗額外算力。例如需要從上個 checkpoint 接續做，需要去讀取資料造成 IO，或是資料需要做 rebalance &amp;hellip;等等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你的應用需要有 graceful shutdown 的機制，那你務必要細心理解這邊的步驟。並仔細安排安全下樁的步驟。又或是無法保證在先占虛擬機回收的作業時限內，完成優雅終止，需要考慮其他可能的實作解法。&lt;/p&gt;
&lt;p&gt;這邊有幾個面向要注意&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;GCP 如何終止先占節點&lt;/li&gt;
&lt;li&gt;GCP 移除節點對 GKE 、以及執行中應用的影響&lt;/li&gt;
&lt;li&gt;GKE 集群如何應對的節點失效&lt;/li&gt;
&lt;li&gt;GCP 自動調度補足新的先占節點&lt;/li&gt;
&lt;li&gt;GKE 集群如何應對節點補足&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;三個重點&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先占虛擬機終止對集群的影響&lt;/li&gt;
&lt;li&gt;Pod 隨之終止對應用的影響，是否能夠優雅終止&lt;/li&gt;
&lt;li&gt;有沒有方法可以避免上面兩者的影響&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;劇透一下：有的，有一些招式可以處理。讓我們繼續看下去。&lt;/p&gt;
&lt;h3 id=&#34;gcp-如何終止虛擬機&#34;&gt;GCP 如何終止虛擬機&lt;/h3&gt;
&lt;p&gt;先占虛擬機的硬體終止步驟與一般隨選虛擬機相同，所以我們要先理解&lt;a href=&#34;https://cloud.google.com/compute/docs/instances/stop-start-instance&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;虛擬機的停止流程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;這裡指的終止 (Stop) 是&lt;a href=&#34;https://cloud.google.com/compute/docs/instances/instance-life-cycle&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;虛擬機生命週期&lt;/a&gt; 的 RUNNING -&amp;gt; instances.stop() -&amp;gt; STOPPING -&amp;gt; TERMINATED 的步驟。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;instances.stop()&lt;/li&gt;
&lt;li&gt;ACPI shutdown&lt;/li&gt;
&lt;li&gt;OS 會進行 shutdown 流程，並嘗試執行各個服務的終止流程，以安全的終止服務。如果虛擬機有設定&lt;a href=&#34;https://cloud.google.com/compute/docs/shutdownscript&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Shtudown Script&lt;/a&gt; 會在這步驟處理&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cloud.google.com/compute/docs/instances/deleting-instance&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;等待至少 90 秒&lt;/a&gt;，讓 OS 完成終止的流程
&lt;ul&gt;
&lt;li&gt;逾時的終止流程，GCP 會直接強制終止，就算 shutdown script 還沒跑完&lt;/li&gt;
&lt;li&gt;GCP 不保證終止時限的時間，官方建議不要寫重要的依賴腳本在終止時限內&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;虛擬機變成 TERMINATED 狀態&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;gcp-如何終止先占虛擬機&#34;&gt;GCP 如何終止先占虛擬機&lt;/h3&gt;
&lt;p&gt;與隨選虛擬機不同&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先占虛擬機的時間 30 秒&lt;/li&gt;
&lt;li&gt;搭配 GKE 使用 Managed Instance Group，終止的虛擬機會被刪除，Autoscaler 會啟動新的虛擬機&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一樣先看&lt;a href=&#34;https://cloud.google.com/compute/docs/instances/preemptible?hl=zh-tw#preemption-process&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;先占虛擬機的說明文件：終止流程&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;資料中心開始回收先占虛擬機，選中我們專案其中的一台先占虛擬機&lt;/li&gt;
&lt;li&gt;Compute Engine 傳送 ACPI G2 Soft Off，這裡 OS 會試圖安全關變服務，也會執行 &lt;a href=&#34;https://cloud.google.com/compute/docs/instances/create-start-preemptible-instance?hl=zh-tw#handle_preemption&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;shutdown script&lt;/a&gt;，可以做簡短的優雅終止&lt;/li&gt;
&lt;li&gt;30秒後，ACPI G3 Mechanical off&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但 30 秒能做什麼？只能快速的交代當前進度。如果應用需要花時間收尾，保存工作進度，可能會產生許多問題&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GCP 不保證終止時限的時間，官方建議不要寫重要的依賴腳本在終止時限內&lt;/li&gt;
&lt;li&gt;在面對大量 IO 的工作，可能會導致者台虛擬機的大量應用一起進入優雅終止，先占虛擬機最後耗盡資源，來不及做完&lt;/li&gt;
&lt;li&gt;如果可能會超時，或是沒完成會有資料遺失風險，就不能在這個階段處理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;依賴 shutdown script 做收尾是危險的，我們之後要想辦法處理這個不保證做完的優雅終止。&lt;/p&gt;
&lt;p&gt;如果應用本身有容錯的框架，或是有容錯機制，我們這邊要額外做的工作就會少很多。例如許多程式框架提供自動重啟的功能，在外部保存 checkpoint，worker 只負責運算，終止信號一進來，也不用保存，直接拋棄未完成的工作進度，留待繼起的 worker 從 checkpoint 接手。&lt;/p&gt;
&lt;h3 id=&#34;preemption-selection&#34;&gt;Preemption selection&lt;/h3&gt;
&lt;p&gt;除了 24 小時的壽命限制會終止虛擬機，資料中心的事件也會觸發主動的虛擬機回收，&lt;a href=&#34;https://cloud.google.com/compute/docs/instances/preemptible?hl=zh-tw#limitations&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;由 GCP 主動觸發的回收機制機率很低&lt;/a&gt;，會根據每日每個區域 (zone) 的狀態而定。這裡描述資料中心啟動的臨時回收。&lt;/p&gt;
&lt;p&gt;GCP 不會把所你手上的 preemptible 機器都收走，而是依照&lt;a href=&#34;https://cloud.google.com/compute/docs/instances/preemptible?hl=zh-tw#preemption-process&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;一定的規則&lt;/a&gt;，選擇一個比例撤換的機器。&lt;/p&gt;
&lt;p&gt;先看文件敘述&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Compute Engine 會避免從單一客戶移除太多先占虛擬機&lt;/li&gt;
&lt;li&gt;優先移除新的虛擬機，偏向保留舊的虛擬機 (但最多仍活不過 24hr)&lt;/li&gt;
&lt;li&gt;開啟後馬上被移除的先占虛擬機不計費&lt;/li&gt;
&lt;li&gt;機器尺寸較小的機器，可用性較高。例如：16 cpu 的先占虛擬機，比 128 cpu 的先占虛擬機容易取得&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;GCP 每天平均會移除一個專案中 5% - 15% 的虛擬機，從用戶的角度我們需要預期至少這個程度的回收。不過這個比例，GCP 也不給予任何保證。以筆者經驗，只能說絕大部分的時候，都不會擔心超過這個比例的回收，但是還是要做好最壞的打算，如果臨時無法取得足夠的先占虛擬機，要有方法暫時補足隨選虛擬機。&lt;/p&gt;
&lt;h3 id=&#34;gke&#34;&gt;GKE&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://cloud.google.com/kubernetes-engine/docs/how-to/preemptible-vms#kubernetes_constraint_violations&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;使用先占虛擬機會違反 Kubernetes 的設計&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Pod grace period 會被忽略&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kubernetes.io/zh/docs/concepts/workloads/pods/disruptions/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Pod disreuption budget&lt;/a&gt;，不會被遵守 (可能會超過)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;對應用的影響&#34;&gt;對應用的影響&lt;/h3&gt;
&lt;p&gt;GCP 觸發的 Preemptible process，對應用的影響&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;involuntary disruptions，GCP 送 ACPI G2 Soft Off&lt;/li&gt;
&lt;li&gt;OS 終止服務，包含執行 Kubernetes 的 container runtime&lt;/li&gt;
&lt;li&gt;容器內的應用會收到 SIGTERM，啟動 graceful shutdown
&lt;ul&gt;
&lt;li&gt;Kubernetes 提供的 Graceful-shutdown 可能會跑不完&lt;/li&gt;
&lt;li&gt;實務上只是中斷當前工作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://cloud.google.com/solutions/scope-and-size-kubernetes-engine-clusters&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://cloud.google.com/solutions/scope-and-size-kubernetes-engine-clusters&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;大量節點同時回收&#34;&gt;大量節點同時回收&lt;/h3&gt;
&lt;p&gt;由於 GCP 並不保證收回的機器的數量，同時回收的機器量大，還是會衝擊到服務。例如：一次收回 15% 的算力，當然服務還是會受到衝擊。當然這樣事件的機率並不高，但我們仍是需要為此打算。這邊有幾個做法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;預留更多的算力&lt;/li&gt;
&lt;li&gt;使用 regional cluster，在多個 zone 上分配先占虛擬機&lt;/li&gt;
&lt;li&gt;我們自行控制，提前主動回收虛擬機&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;預留更多資源&#34;&gt;預留更多資源&lt;/h3&gt;
&lt;p&gt;這點很直觀，由於使用了更加便宜的機器，我們可以用同樣的成本，開更多的機器。&lt;/p&gt;
&lt;p&gt;退一步說，使用打三折的先占虛擬機，然後開原本兩倍的機器數量&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;總成本是 0.3 * 2 = 0.6 倍&lt;/li&gt;
&lt;li&gt;同時間可用資源是 2 倍&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由於先占節點回收的單位是一個一個虛擬機&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安排合適的機器尺寸&lt;/li&gt;
&lt;li&gt;尺寸較小的先占虛擬機，可用性較高。意思是零碎的先占虛擬機容易取得&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但當然也不能都開太小的機器，這會嚴重影響應用的分配。至於具體需要開多大，可以根據預計在機器上運行的應用，做綜合考量，例如有以下影用需要執行：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;app A: 1 cpu 5 replica&lt;/li&gt;
&lt;li&gt;app B: 3 cpu 5 replica&lt;/li&gt;
&lt;li&gt;app C: 5 cpu 5 replica&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;總共至少 45 cpu ，預期機器負載8 成的話，需要總共 45 / 0.8 = 56 cpu。也許可以考慮&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;8 cpu * 7 先占虛擬機&lt;/li&gt;
&lt;li&gt;4 cpu * 14&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;也舉幾個極端不可行的例子&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;56 cpu * 1
&lt;ul&gt;
&lt;li&gt;這樣的虛擬機回收時的影響範圍 (blast radius) 就是 100% 服務&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;1 cpu * 56
&lt;ul&gt;
&lt;li&gt;機器太瑣碎，可能超出 Qouta (節點數量，IP 數量&amp;hellip;)&lt;/li&gt;
&lt;li&gt;應用會更分散，節點間的內部網路流量會增加&lt;/li&gt;
&lt;li&gt;前幾篇提到的 reserved resource 比例高，會影響應用的部署&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果希望更保險，可以再補上隨選虛擬機混合搭配，例如&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;8 cpu * 7
&lt;ul&gt;
&lt;li&gt;5 先占虛擬機 2 隨選虛擬機&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;4 cpu * 14
&lt;ul&gt;
&lt;li&gt;10 先占虛擬機 4 隨選虛擬機&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;虛擬機區域&#34;&gt;虛擬機區域&lt;/h3&gt;
&lt;p&gt;虛擬機的回收觸發，也是會依據服務的區域 (zone) 回收。意思是節點回收不會同時觸發 asia-east1 中所有 zone 的節點回收，一般來說時間是錯開的 (不過GCP 也不保證這點 XD)。為了維持 GKE 的可用性，我們都會開多個 node-pool 在多個區域下。&lt;/p&gt;
&lt;p&gt;總之避免把機器都放在同個區域中。&lt;/p&gt;
&lt;h3 id=&#34;自行控制的虛擬機汰換&#34;&gt;自行控制的虛擬機汰換&lt;/h3&gt;
&lt;p&gt;簡單來說我們在 24 hr 期限之前，先分批自盡 XD，打散個各個虛擬機的 24 小時限制。&lt;/p&gt;
&lt;p&gt;使用這個有趣的工具 &lt;a href=&#34;https://github.com/estafette/estafette-gke-preemptible-killer&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;estafette-gke-preemptible-killer&lt;/a&gt;，自動汰換先占虛擬機，讓整個繼起虛擬機都分散在 24 小時間。&lt;/p&gt;
&lt;p&gt;estafette-gke-preemptible-killer ，使用上簡單，大家自己看著辦 XD。如果大家有興趣，留言的人多的話，我再另外開一篇細講。&lt;/p&gt;
&lt;h3 id=&#34;小結&#34;&gt;小結&lt;/h3&gt;
&lt;p&gt;為了使用先占虛擬機，我們要多做以下幾件事&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;為應用設計可容錯分散式架構，例如應用可以同時執行一樣的 API server 3 個 replica&lt;/li&gt;
&lt;li&gt;分散 Pod 到合適的機器上，例如設置 PodAntiAffinity&lt;/li&gt;
&lt;li&gt;設定合適的虛擬機大小，合適的分散應用&lt;/li&gt;
&lt;li&gt;使用 &lt;a href=&#34;https://github.com/estafette/estafette-gke-preemptible-killer&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;estafette-gke-preemptible-killer&lt;/a&gt;，自動汰換先占虛擬機&lt;/li&gt;
&lt;li&gt;不依賴應用的 Graceful-shutdown 流程&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Gcp Preemptible Instance Requirement Distributed</title>
      <link>https://chechia.net/en/post/2020-09-22-gcp-preemptible-instance-requirement-distributed/</link>
      <pubDate>Tue, 22 Sep 2020 14:39:00 +0800</pubDate>
      <guid>https://chechia.net/en/post/2020-09-22-gcp-preemptible-instance-requirement-distributed/</guid>
      <description>&lt;p&gt;我們以下幾個需求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;執行短期的 batch job&lt;/li&gt;
&lt;li&gt;執行長期的 user-facing API server&lt;/li&gt;
&lt;li&gt;執行長期的 stateful 資料庫、儲存庫&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;該不該在 Kubernetes 上面跑 database？&lt;/p&gt;
&lt;p&gt;TL;DR ，如果你剛開始考慮這件事，通常的答案都是否定的&lt;/p&gt;
&lt;p&gt;等等，我們這邊不是討論該不該上 Kuberentes ，而是該不該使用先占虛擬機吧。然而由於先占虛擬機節點的諸多限制，光憑先占虛擬機並不適合跑任何持久性的儲存庫。我們這邊仰賴 Kubernetes 的網路功能 (e.g. 服務發現)，與自動管理 (e.g. health check，HPA，auto-scaler)，基於先占虛擬機，建構高可用性的服務架構，來支撐高可用，且有狀態的的儲存庫。&lt;/p&gt;
&lt;p&gt;應用是否適合部署到 Kubernetes 上，可以看這篇 &lt;a href=&#34;https://cloud.google.com/blog/products/databases/to-run-or-not-to-run-a-database-on-kubernetes-what-to-consider&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Google Blog: To run or not to run a database on Kubernetes: What to consider&lt;/a&gt;，如果大家有興趣，再留言告訴我，我再進行中文翻譯。&lt;/p&gt;
&lt;p&gt;文中針對三個可能的方案做分析，以 MySQL 為例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Sass，GCP 的 Cloud SQL
&lt;ul&gt;
&lt;li&gt;最低的管理維運成本&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;自架 MySQL 在 GCP 的 VM 上，自行管理
&lt;ul&gt;
&lt;li&gt;自負完全的管理責任，包含可用性，備份 (backup)，以及容錯移轉 (failover)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;自架 MySQL 在 Kubernetes 上
&lt;ul&gt;
&lt;li&gt;自負完全的管理責任&lt;/li&gt;
&lt;li&gt;Kubernetes 的複雜抽象層，會加重維運工作的複雜程度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然而 RDBMS 的提供商，自家也提供 Operator&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/oracle/mysql-operator&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Oracle 自家提供的 MySQL Operator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/CrunchyData/postgres-operator&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CrunchyData 也有提供的 Postgres Operator&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你就想，所以這些人是想怎樣，RDBMS 放 Kubernetes 上到底是行不行 XD。Google 的文章說明：如果應用本身並不符合 Kubernetes 的工作流程 (Pod life-cycle)，可以透過上述的 Operator 來自動化許多維運的作業，降低維運的困難。&lt;/p&gt;
&lt;p&gt;然而 DB 有千百種，除了 RDBMS 以外，還有另外一批 Database 天生就具有分散式的架構，這些儲存庫部署到 Kubernetes 上，並不會太痛苦 (還是要付出一定的成本XD)，但是卻可以得益於 Kubernetes 的諸多功能。&lt;/p&gt;
&lt;p&gt;底下我們先根據分散式的儲存庫做概觀描述，本系列文的最後，會根據時間狀況，做實例分享：Cassandra 或是 CockroachDB。提供各位一點發想，並根據需求去選擇需要的儲存庫&lt;/p&gt;
&lt;p&gt;「行不行要問你自己了施主，技術上都可以，維運上要看看你的團隊有沒有那個屁股吃這份藥 XD」&lt;/p&gt;
&lt;h3 id=&#34;distributed-database&#34;&gt;Distributed Database&lt;/h3&gt;
&lt;p&gt;底下非常粗淺的簡介分散式儲存庫的概念，提供一個基準點，幫助接下來討論是否可以使用先占虛擬機。這邊要強調，儲存庫的類型千百種，底層的各種實作差異都非常大，底下的模型是基於 cassandra 但不會走太多細節。 cassandra 的規格有機會再細聊。&lt;/p&gt;
&lt;p&gt;當後端應用已經順利水平拓展之後，整體服務的效能瓶頸往往都壓在後端 DB 上。這些不同的 DB 面向不同的需求，當需求符合時，可以考慮使用這些解決方法。&lt;/p&gt;
&lt;p&gt;這邊要強調，不是放棄現有的 RDBMS ，完全移轉到新的資料庫，這樣的成本太高，也沒有必要性。更好的做法，是搭配既有的關聯性資料庫，將不是核心業務的資料處理抽出，移轉到合適的資料庫上。讓不同需求的資料儲存到更合適的儲存庫，是這段話要強調的重點，關連式資料庫也不是唯一選擇。&lt;/p&gt;
&lt;p&gt;分散式的資料庫有以下特徵&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分散式節點集群 (Cluster)：資料庫是多個節點共存，而非 single master, multiple slaves 的架構
&lt;ul&gt;
&lt;li&gt;配合共識算法 (consensus algorithm) 溝通節點之間的資訊&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;無單點錯誤 (Single-point failure)：e.g. 不會因為 master 錯誤導致整個服務失效&lt;/li&gt;
&lt;li&gt;高可用(High Availitility：可以承受集群中一定數量虛擬機故障，服務仍然可用&lt;/li&gt;
&lt;li&gt;資料 sharding 到不同節點上&lt;/li&gt;
&lt;li&gt;複本 (replica)
&lt;ul&gt;
&lt;li&gt;節點複本 (node replicas)：多個節點提供服務，提供流量的帶寬與可用性&lt;/li&gt;
&lt;li&gt;資料複本 (data replicas)：在多個節點上儲存資料，提供資料的備份，同時也提供讀取帶寬與可用性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;從以上特徵來說，使用此架構的服務可以承受先占虛擬機的不定時終止，或許可以使用。&lt;/p&gt;
&lt;p&gt;實務上有非常多需要注意，需要依據各自服務的性質，各自處理。常見的問題舉例如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;應用可以容錯 (fault-tolerent)，然而錯誤發生後，會需要消耗復原成本，例如重啟後需要花時間初始化，或是在多節點上進行 data rebalance。&lt;/li&gt;
&lt;li&gt;可以承受突然的錯誤，使用先占虛擬機，變成每日固定會承受必然的錯誤。這裡犧牲了部分算力，甚至造成隱性的維護成本，最後是否符合節省成本的需求。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;都是需要仔細了解解決方案，並且分析需求，來評估是否有合乎成本。&lt;/p&gt;
&lt;h1 id=&#34;gke&#34;&gt;GKE&lt;/h1&gt;
&lt;p&gt;以上分析了三種常見需求例子：從 batch job，user-facing service，與 distributed database。明天會實際搬出 GKE 與 GCP Preemptible Instance 的技術規格，與大家實際討論。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Gcp Preemptible Instance</title>
      <link>https://chechia.net/en/post/2020-09-21-gcp-preemptible-instance/</link>
      <pubDate>Mon, 21 Sep 2020 09:22:17 +0800</pubDate>
      <guid>https://chechia.net/en/post/2020-09-21-gcp-preemptible-instance/</guid>
      <description>&lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;
&lt;p&gt;鐵人賽的第二部分，要帶來公有雲省錢系列文章。&lt;/p&gt;
&lt;p&gt;架構的成本，很多時候會影響架構的設計與需求。公司的營運都需要在成本與需求之前平衡，成本其實是影響公司決策的重要因素。身為架構管理員，應該要試著量化並且進行成本管理，提出解決方案時，也需要思考如何幫公司開源節流。&lt;/p&gt;
&lt;p&gt;一昧消減架構的成本也未必是最佳方案，帳面上消減的成本有時也會反映在其他地方，例如：使用比較便宜的解決方案，或是較低的算力，但卻造成維運需要花更多時間維護，造成隱性的人力成本消耗。用什麼替代方案 (trade-off) 省了這些錢。&lt;/p&gt;
&lt;p&gt;Kubernetes 是一個很好的例子：例如：有人說「Kubernetes 可以省錢」，但也有人說「Kubernetes 產生的 Overhead 太重會虧錢」。&lt;/p&gt;
&lt;p&gt;「要不要導入 Kubernetes 是一個好問題」。應該回歸基本的需求，了解需求是什麼。例如：Google 當初開發容器管理平台，是面對什麼樣的使用需求，最終開發出 Kubernetes，各位可以回顧前篇文章「Borg Omega and Kubernete，Kubernetes 的前日今生，與 Google 十餘年的容器化技術」，從 Google 的角度理解容器管理平台，反思自身團隊的實際需求。&lt;/p&gt;
&lt;p&gt;這套解決方案是否真的適合團隊，解決方案帶來的效果到底是怎樣呢？希望看完這系列文章後，能幫助各位，從成本面思考這些重要的問題。&lt;/p&gt;
&lt;p&gt;這篇使用 GCP 的原因，除了是我最熟悉的公有雲外，也是因為 GCP 提供的免費額度，讓我可以很輕鬆地作為社群文章的 Demo，如果有別家雲平台有提供相同方案，請留言告訴我，我可能就會多開幾家不同的範例。&lt;/p&gt;
&lt;h1 id=&#34;先占虛擬機-tldr&#34;&gt;先占虛擬機 TL;DR&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;先占虛擬機為隨選虛擬機定價的 2-3 折，使用先占虛擬機可能可以節省 7 成的雲平台支出&lt;/li&gt;
&lt;li&gt;先占虛擬機比起隨選虛擬機，外加有諸多限制，e.g. 最長壽命 24 hr、雲平台會主動終止先占虛擬機&amp;hellip;等&lt;/li&gt;
&lt;li&gt;配合使用自動水平擴展 (auto-scaler)，讓舊的先占虛擬機回收的同時，去購買新的先占虛擬機&lt;/li&gt;
&lt;li&gt;配合可容錯 (fault-tolerent) 的分散式應用，讓應用可以無痛在虛擬機切換轉移，不影響服務&lt;/li&gt;
&lt;li&gt;要讓應用可以容錯，需要做非常多事情&lt;/li&gt;
&lt;li&gt;搭配 kubernetes ，自動化管理來簡化工作&lt;/li&gt;
&lt;li&gt;配合正確的設定，可以穩定的執行有狀態的分散式資料庫或儲存庫&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;或是看 Google 官方 Blog：&lt;a href=&#34;https://cloud.google.com/blog/products/containers-kubernetes/cutting-costs-with-google-kubernetes-engine-using-the-cluster-autoscaler-and-preemptible-vms&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cutting costs with Google Kubernetes Engine: using the cluster autoscaler and Preemptible VMs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;預計內容&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;需求假設、釐清需求，並且精準計價&lt;/li&gt;
&lt;li&gt;精準計價使用先占虛擬機的節省成本&lt;/li&gt;
&lt;li&gt;先占虛擬機的規格、額外限制&lt;/li&gt;
&lt;li&gt;額外限制，造成技術要多做很多額外的事情&lt;/li&gt;
&lt;li&gt;實務經驗分享：API server&lt;/li&gt;
&lt;li&gt;實務經驗：從使用隨選虛擬機，移轉到先占虛擬機，公司實際導入經驗&lt;/li&gt;
&lt;li&gt;實務經驗：Elasticsearch&lt;/li&gt;
&lt;li&gt;實務經驗分享：其他分散式資料庫，也許是 Cassandra 或是 cockroachDB&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上面的內容不曉得會寫幾篇看感覺 XD&lt;/p&gt;
&lt;p&gt;有寫過鐵人賽的都知道 30 篇真的很漫長，一篇文章幾千字，都要花好幾個小時。我去年後半，真的都會看讀者的留言跟按讚，取暖一波，才有動力繼續寫。留言的人多就會多寫，留言的人少就會少寫，各位覺得文章還看得下去，請務必來我粉專按讚留個言，不管是推推、鞭鞭、或是有想看的文章來許願，都十分歡迎。有你們的支持，我才有動力繼續寫。&lt;/p&gt;
&lt;p&gt;請大家務必以實際行動支持好文章，不要讓劣幣驅逐良幣。不然 iThome 上面之後只剩洗觀看數的熱門文章了 XD&lt;/p&gt;
&lt;p&gt;當然，沒人留言我就會當作自己才是垃圾文 (自知之明XD)，就會收一收回家嚕貓睡覺，掰掰~&lt;/p&gt;
&lt;p&gt;-&amp;gt;我的粉專，等你來留言&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Borg Omega and Kubernetes Translation 全文翻譯</title>
      <link>https://chechia.net/en/post/2020-09-12-borg-omega-and-kubernetes/</link>
      <pubDate>Sat, 12 Sep 2020 13:50:52 +0800</pubDate>
      <guid>https://chechia.net/en/post/2020-09-12-borg-omega-and-kubernetes/</guid>
      <description>&lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;
&lt;p&gt;這是原文完整版本。太長不讀 (TL;DR) 請見&lt;a href=&#34;https://chechia.net/en/post/2020-08-26-borg-omega-and-kubernetes-tldr/&#34;&gt;Borg Omega and Kubernetes 前世今生摘要&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原文：https://storage.googleapis.com/pub-tools-public-publication-data/pdf/44843.pdf&lt;/p&gt;
&lt;h1 id=&#34;摘要&#34;&gt;摘要&lt;/h1&gt;
&lt;p&gt;在 container 技術夯起來前，Google 已經做了 container 十幾年，過程中發展出需三套容器管理系統。雖然每一代系統的開發需求不同，但每一代都深受上一代影響。這篇文章描述 Google 開發這些系統時，學到的經驗。&lt;/p&gt;
&lt;p&gt;第一套 container management 系統是 Borg，為了管理 1. 長期執行的服務 2. 批次的短期工作 (batch job)，原本分別是由 Babysitter 與 Global Work Queue 兩套系統分開管理。後者的架構深刻影響 Borg，但 Global Work Queue 專注於 batch job。兩套系統都在 Linux control groups 之前。Borg 將上述兩種應用放在共享的機器上，來增加資源的使用率，以節省成本。這種共享基於支援 container 的 Linux Kernel (Google 也貢獻許多 Linux kernel container 程式碼)，提供更好的隔離 (isolation) 給延遲敏感的使用者服務 (latency-sentitive user-facing services)，以及消耗大量 cpu 的 batch 程式。&lt;/p&gt;
&lt;p&gt;越來越多應用都在 Borg 上開發執行， Google 的應用與 infratructure 團隊開發許多工具與服務，形成 Borg 生態系。這些系統提供設定 (configure) 與更新 (update) 工作、預測資源需求、動態推送設定到執行中的工作、服務發現 (service discovery) 與負載均衡 (Load balancing)，等等功能。這些生態系的開發基於 Google 不同團隊的需求，產生一個不同起源 (heterogeneous)、只針對各別需求的 (ad-hoc) 一個堆不同系統，Borg 的使用者需要使用不同的程式語言與程序，來與這些系統互動。Borg 仍然是 Google 主要的容器管理系統，因為他規模 (scale) 巨大，功能多樣，而且極度堅固 (robustness)。&lt;/p&gt;
&lt;p&gt;Omega 是 Borg 的下一代，目的是改善 Borg 生態系的軟體工程。Omega 承襲許多 Borg 測試成功的模式，但不同於 Borg，Omega 有完整的架構設計，整體更加一致。Omega 將集群狀態 (cluster state) 存放在中心化 (centralized)、基於 Paxos 算法、交易導向 (transaction-oriented) 的儲存系統，讓集群的控制面板 (control panel) 存取，例如 scheduler。Omega 使用樂觀的併發控制 (optimistic concurrency control) 來處理偶發的衝突，這一層解藕 (decoupling) 的設計，使得原先的 Borgmaster 的功能可以拆分成多個元件，取代原本單一 (monolithic) 集中 (centralized) 的 master，被所有變更請求堵塞。許多 Omage 成功的創新也會被迭代回去 Borg 中。&lt;/p&gt;
&lt;p&gt;第三套 Google 開發的容器管理系統是 Kubernetes，這時外界工程師也開始對 Linux 容器有興趣，而 Google 同時在開發並推展自己的公有雲架構。Kubernetes 在這樣的背景下構思並開發。與 Borg 及 Omega 不同，Kubernetes 是開源軟體，不限於 Google 內部開發。Kubernetes 內部有共享的持久層儲存 (persistent store)，服務元件持續監測有關物件，與 Omega 類似。不同的是，Omega 允許信任的控制面板的元件直接存取儲存庫，Kubernetes 則透過 domain-specific 的 REST API 存取，來提供高階 (higher-level) 的 API 版本控制、驗證、語意處理 (semantics)、以及存取政策 (policy)，來支援更廣泛的用戶端。更重要的是 Kubernetes 著重工程師在 cluster 上開發與執行應用的體驗，簡化複雜分散式系統 (distributed system) 的管理與部屬 (deploy)，同時仍能透過容器來提升資源的使用率。&lt;/p&gt;
&lt;p&gt;這篇文章描述 Google 從 Borg 到 Kubernetes 獲得的知識與經驗。&lt;/p&gt;
&lt;h1 id=&#34;容器-containers&#34;&gt;容器 (Containers)&lt;/h1&gt;
&lt;p&gt;回顧歷史，第一個容器只提供 root file system (透過 chroot)。FreeBSD jail 進一步延伸出額外的命名空間 (namespace) 例如 process ID。Solaris 大幅地探索相關的新功能。Linux control groups (cgroups) 吸收這些想法，直到今日仍持續開發。&lt;/p&gt;
&lt;p&gt;容器提供資源隔離 (resource isolation)，Google 得以大幅提升資源使用率 (utilization) 超出當時產業平均值，例如 Borg 使用容器，將批次暫時工作、與面對用戶需要注意延遲的應用，兩者放在同樣的物理機器上。用戶應用需要預留更多額外的資源，來處理突然產生的負載高峰 (load spikes) 以及錯誤處理 (fail-over) ，這些預留的資源常常都不會用到，可以轉讓批次工作使用。容器提供的資源管理工具實現此類需求，kernel-level 的資源隔離也確保程序之間不會互相干擾。Google 開發 Borg 中，同時也提交新功能給 Linux 容器，來滿足上述的需求。然而目前的隔離並不完整，如果 Linux kernel 不管理的資源，容器自然也無法格理，例如 level-3 的處理器快取 (level-3 processor cache) 與記憶體帶寬 (memory bandwith)，容器還需要增加一層安全保護層 (例如虛擬機器 Virtual Machine) 才能對付公有雲上出現的惡意行為。&lt;/p&gt;
&lt;p&gt;現代的容器不只提供隔離機制，更提供映像檔 (image)，在這個檔案上建構容器的應用。Google 使用 Midas Package Manager (MPM) 來建構並部屬容器映像檔，隔離機制與 MPM package 的關係，可以對比 Docker daemon 與 Docker image registry。這個章節描述的「容器」同時包含兩個概念：隔離、映像檔。&lt;/p&gt;
&lt;h1 id=&#34;應用導向的架構-application-oriented-infrastructure&#34;&gt;應用導向的架構 (Application-oriented infrastructure)&lt;/h1&gt;
&lt;p&gt;隨著時間證明，容器不只能提供高階的資源使用率，容器化 (containerization) 使資料中心 (data center) 從原本機器導向 (machine-oriented) 變成應用導向 (application-oriented)，這個段落提供兩個例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;容器封裝 (encapsulate) 應用的環境 (environment)，在機器與作業系統的細節上，增加一層抽象層，解藕兩件事情：應用開發、部屬到架構。&lt;/li&gt;
&lt;li&gt;良好設計的容器與映像檔只專注在單一個應用，管理容器意味管理應用，而不是管理機器。這點差異使得管理的 API，從機器導向變成影用導向，大幅度的改善應用的部屬與監控。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;應用的環境-application-environment&#34;&gt;應用的環境 (Application environment)&lt;/h3&gt;
&lt;p&gt;原本 kernel 內的 cgroup、chroot、與命名空間，是用來保護應用不被旁邊其他應用的雜訊影響。將這些工具與容器映像檔一起使用，產生一層抽象層，分離應用、與底下的 (各種不同家的) 作業系統。解藕映像檔與作業系統，進一步提供相同的環境給開發環境 (development) 與生產環境 (production)，降低環境間的不一致性造成的問題，最終提升開發的可靠程度、並加速開發的流程。&lt;/p&gt;
&lt;p&gt;建構這層抽象的關鍵是，使用密閉的容器映象檔 (hermetic container image) ，將所有應用有關的依賴 (dependencies) 都打包，整包部屬到容器中。正確執行的話，容器對外部的依賴只剩下 Linux kernel 系統調用介面 (system-call interface)。這層介面大幅改善映象檔的部屬方便性 (protability)，但目前機制仍不完美，應用仍然暴露在某些作業系統的介面上，特別是 socket options、/proc、以及 ioctl 的調用參數。Google 希望透過推廣開放容器倡議 (Open Container Initiative) 來清楚界定，上述介面與容器的抽象層。&lt;/p&gt;
&lt;p&gt;次外，容器提供的隔離與最小依賴，在 Google 證明非常有效，容器是 Google 架構上唯一的可執行單位 (runnable entity)，進一步使 Google 只提供少數的作業系統版本給所有機器，只需要少數的維護人員來負責管理版本。&lt;/p&gt;
&lt;p&gt;密閉容器映想檔有很多方式達成，在 Borg 建構映想檔時，應用的執行檔 (binary) 靜態連結到可用的程序庫 (library) 版本，程式庫在公司內部存放。至此 Borg 容器映像檔還不是完全密閉，底下還有依賴一層基底映象檔 (base image)，直接事先安裝到機器上，而不是隨映像檔部屬，基底映象檔包含通用工具例如 tar 與 libc 程式庫，因此更新基底映象檔仍會影響應用，偶爾會產生大麻煩。&lt;/p&gt;
&lt;p&gt;現代的容器映像檔格式，如 Docker 與 ACI，都加強這層抽象、提供更緊密的封裝，移除特定作業系統的依賴性，並要求使用者在分享映象檔內容時，必須明確宣告。&lt;/p&gt;
&lt;h3 id=&#34;容器作為管理單位-container-as-the-unit-of-management&#34;&gt;容器作為管理單位 (Container as the unit of management)&lt;/h3&gt;
&lt;p&gt;圍繞容器建構管理 API，而非圍繞機器，使得資料中心的「Primary key」從機器變成應用。帶來許多好處：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;應用工程師與維運團隊 (operation team) 不需再煩惱機器與作業系統的細節&lt;/li&gt;
&lt;li&gt;架構團隊 (infrastructure team) 獲得更多升版或是調度硬體的彈性，實際對應用與開發團隊的影響非常小&lt;/li&gt;
&lt;li&gt;管理系統收集應用的監測數據 (例如 CPU 與 Memory 使用 metrics)，而非機器的監測數據，直接提升應用的監測與自我檢查 (introspection)，特別是擴展 (scale-up)、機器錯誤、或是維護時，造成應用移到其他位置時，監測依然可用。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;容器提供許多切入點給泛用 API (generic API)，泛用 API 使資訊在管理系統與應用之間流動，但其實兩者互相不清楚對方的實作細節。在 Borg 中有一系列的 API 連結到所有容器，例如 /healthz 端點回報應用的健康程度給協調管理者 (orchestrator)，當發現不健康的應用，自動終止並重啟應用。這個自動修復功能是可靠的分散式系統的基礎。(Kubernetes 也提供類似功能，透過 HTTP 端點或是 exec command 來檢查容器內部的應用)&lt;/p&gt;
&lt;p&gt;容器提供、或是提供給容器的資訊，可以透過許多使用者介面呈現。Borg 提供可以動態更新的文字狀態訊息，Kubernetes 提供 key-value 的 annotation 存放在給個物件的 metadata，這些都能溝通應用。annotation 可以是容器自行設定、或是由管理系統設定 (例如滾動更新版本時標註新版本)。&lt;/p&gt;
&lt;p&gt;容器管理系統可以取得容器內部訊息，例如資源使用狀況、容器的 metadata，並傳播給日誌 (logging) 或是監控 (monitoring)，例如使用者名稱、監控任務名稱、用戶身分。甚至進一步在節點維護時，提早提供安全終止 (graceful-termination) 的警示。&lt;/p&gt;
&lt;p&gt;容器有其他方式可以提供應用導向的監測，例如 Linux Kernel cgroups 會提供應用的資源使用率，這些資訊可以擴展，並將客製化的 metrics 構過 HTTP API 送出。基於這些資料，進一步開發出泛用工具如自動擴展 (auto-scaler) 與 cAdvisor，他們不需要知道應用的規格就可以記錄 metrics。由於容器本身是應用，因次不需要在實體或虛擬機器、與多個應用之間，做信號多工轉發或多路分配 (multiplex / demultiplex signals)。這樣更簡單、更堅固、並且可以產生精度更高的 metrics 與日誌，並提供更精細的控制操作。你可以對比使用 ssh 登入機器，並且使用 top 指令監測。雖然工程師可以 ssh 登入容器，但很少需要這樣做。&lt;/p&gt;
&lt;p&gt;應用導向變遷在管理架構上產生更多回響，監測只是其中一個。Google 的附載均衡器 (load balancer) 不再根據機器做附載均衡，而是根據應用實體 (application instances)。日誌會根據應用打上標籤 (key) 而不是機器，因此可以跨機器的收集所有相同應用的日誌，而不會影響其他的應用日誌或是影像作業系統。我們可以檢測應用失效，更容易的描述錯誤原因，不需要先拆解處理機器的各層信號。由於容器實體的身分資訊，從基礎上都是由容器管理系統控制，工程師可以明確的指定應用的執行身分，使得應用更容易建構、管理、除錯。&lt;/p&gt;
&lt;p&gt;最後，雖然上述都針對容器與應用在一對一的狀況下，但實務上我們需要套裝的容器群 (nested containers)，這群容器一起排程到相同機器上，最外層的容器提供資源，內層的容器提供部屬的隔離。Borg 中，最外層容器叫做資源分配 (resource allocation or alloc)，在 Kubernetes 上稱做 Pod。Borg 允許最上層的應用直接跑在外層的 alloc 上，但這點產生了一些不便，所以這點在 Kubernetes 做了調整，應用永遠跑在最外層 Pod 的內部，就算只有單一一個容器。&lt;/p&gt;
&lt;p&gt;一個常見的使用情境，是一個 Pod 內部跑一個複雜的應用，大部分的應用都是一個一個子容器 (child containers)，其他的子容器則執行輔助工具，例如 log rotation 或是將日誌移轉到分散式檔案系統。對比把上述功能都打包到 binary 執行檔中，拆分更容易讓不同團隊各自開發負責的功能，拆分還提供更好的耐用程度 (就算主要應用終止，子容器仍能成功將日誌移轉出去)，更容易組裝應用 (composability) (由於每個服務都是獨立運作在各自的容器中，因此可以直接增加新的支援服務)，提供更精細的資源隔離 (所有容器資源隔離，所以日誌服務不會搶占主要應用的資源，反之亦然)。&lt;/p&gt;
&lt;h1 id=&#34;協調管理只是開始而不是終點-orchestration-is-the-beginning-not-the-end&#34;&gt;協調管理只是開始，而不是終點 (Orchestration is the beginning, not the end)&lt;/h1&gt;
&lt;p&gt;Borg 的初衷只是分配不同的工作附載 (workload) 到相同的機器上，來提升資源使用率。然而 Borg 生態系中，支援系統的快速演化，表明容器管理系統本身只是一個起點：通往一個新的分散式系統開發與管理環境。許多新的系統在 Borg 上打造、嵌入 Borg、或是圍繞 Borg 打造，提升 Borg 的基本容器管理服務，底下是部分服務清單：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;命名與服務發現 (Naming and service discovery) Borg Name Service (BNS)&lt;/li&gt;
&lt;li&gt;主節點選舉 (master election) 使用 Chubby&lt;/li&gt;
&lt;li&gt;應用感知的 (application-aware) 的負載均衡&lt;/li&gt;
&lt;li&gt;自動水平擴展 (horizontal) 與垂直擴展 (vertical)&lt;/li&gt;
&lt;li&gt;新的執行檔與設定檔的滾動升級工具 (rollout)&lt;/li&gt;
&lt;li&gt;工作流程工具 (workflow) (例如在不同工作階段，執行多任務的分析 pipeline)&lt;/li&gt;
&lt;li&gt;監控工具，可以收集容器資訊、整合統計、在 dashboard 上顯示、並可以觸發告警&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這些服務都是用來處理開發團隊面臨的問題，Google 選出成功的服務並廣泛的應用，讓工程師工作更加輕鬆。然而這些工具大多各自需要特別的 (idiosyncratic) API，例如需要知道檔案的位置，也需要 Borg 的深度整合。產生一個不好的副作用，就是部屬 Borg 生態系變得更複雜了。&lt;/p&gt;
&lt;p&gt;Kubernetes 試圖降低這些複雜度，因此導入一致性設計的 API (consistent API)，例如每個 Kubernetes 物件都會有三個基礎內容：ObjectMetadata、Specification (Spec)、以及 Status。&lt;/p&gt;
&lt;p&gt;所有物件的 ObjectMetadata 都是一樣的，包含物件的名稱、UID、物件的版本 (作為樂觀併發控制 optimistic concurrency control 時使用)、標籤 (key-value label)。Spec 與 Status 的內容因物件型別有所不同，但核心概念一致：Spec 是描述期望狀態 (desired state)，而 Status 是紀錄物件的當前狀態 (current state)。&lt;/p&gt;
&lt;p&gt;統一 API 帶來很多好處，從系統獲取資訊更加簡單：所有物件都有相同的資訊，才可以開發所有物件都適用的泛用工具，而這點更進一步，使工程師開發的使用體驗更加一致。從 Borg 與 Omega 中的經驗學習，所以 Kubernetes 是一堆組合的區塊打造而成，使用者還可以自行擴展。有統一的 API 以及 object-metadata 結構讓這件事更簡單。例如 Pod API 用戶可以使用、Kubernetes 內部元件也使用、外部的自動化工具也使用。一致性繼續延伸，Kubernetes 允許用戶動態增加客製化的 API，與 Kubernetes 核心的 API 一起工作。&lt;/p&gt;
&lt;p&gt;一致性的促成也仰賴 Kubernetes 自身 API 的解藕。把各自元件的面向拆開，讓更高階的服務共享相同的底層基礎實作。例如拆分 Kubernetes 副本控制器 (replication controller) 與水平自動擴展系統 (horizontal auto-scaling system)，副本控制器確保一個腳色的 (ex. 前端網頁) 存在的數量符合期望的數量，自動擴展器則基於副本控制器的功能，只單純調整 Pods 的期望狀態 (desired state)，而不需負責 Pod 的增減，讓自動擴展器可以實作更多使用上的需求，例如預測使用，並可以忽略底下執行的實作細節。&lt;/p&gt;
&lt;p&gt;API 解藕也讓許多關聯，但是不盡相同的元件構成近似。例如 Kubernetes 有三個形式的副本 Pod：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ReplicationController：持續執行的容器副本 (例如 web server)&lt;/li&gt;
&lt;li&gt;DaemonSet：每個節點都有一個實體 (例如日誌收集器)&lt;/li&gt;
&lt;li&gt;Job：執行到工作完成的控制器，知道如何 (平行的) 啟動工作到結束工作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;雖然有各自的執行政策 (policy) ，三個控制器都有相同的 Pod 物件，描述希望執行的容器。&lt;/p&gt;
&lt;p&gt;一致性也仰賴 Kubernetes 內部元件的相同設計模式 (design patterns)。控制器調和迴圈 (reconciliation controller loop) 是 Borg、Omega、Kubernetes 都共享的設計理念，為了提升系統的彈性：迴圈不斷比對期望狀態 (要求多少符合 label-selector 的 Pod 存在)、與實際狀態 (控制器實際觀察到的數量)，然後控制器採取行動，盡量收斂 (converge) 實際狀況與期望狀況。由於所有行動都基於觀察結果，而非一個狀態圖，調和迴圈更能承受錯誤、更能抵抗擾亂、更加堅固：當一個控制器出錯，只要重啟，就可以繼續上次中斷的工作。&lt;/p&gt;
&lt;p&gt;Kubernetes 設計成一堆微服務 (microservice) 的組合，並透過各個小型的控制迴圈 (control loop)，來達成整體的編排結果 (choreography) - 一個期望的狀態，由各個分散的自動元件，協作達成。這個意識的設計選擇，對比一個中心化協調管理系統 (centralized orchestration)，後者更容易建構，但面對不可預期的錯誤與變更時，更顯脆弱與僵化。&lt;/p&gt;
&lt;h1 id=&#34;前車之鑑-things-to-avoid&#34;&gt;前車之鑑 (Things to avoid)&lt;/h1&gt;
&lt;p&gt;Google 在開發這些系統時，學到一些最好別做的事情，我們提供這些資訊，所以其他人可以避免重複的錯誤，而把犯錯的成本放在新的錯誤上。&lt;/p&gt;
&lt;h3 id=&#34;不要使用容器管理系統管理-port-number&#34;&gt;不要使用容器管理系統管理 Port number&lt;/h3&gt;
&lt;p&gt;Borg 上所有容器都使用宿主機器的 IP，Borg 在分配時便指派給每個容器各自的 port number。每個容器移動到新機器時會取得一個新的 port number，有時在本機重啟也會拿到新的。這點表示既存的網路服務 (例如 DNS) Google 都必須自行改動並使用自維護的版本；服務的客戶端並不能主動獲得服務的 port number 資訊，需要被動告知；port number 也不能放在 URLs 中，還需要額外的轉址機制；所有基於 IP 運作的工具都需要改成使用 IP:Port。&lt;/p&gt;
&lt;p&gt;有鑑於此，Kubernetes 上每個 Pod 分配一個 IP，讓應用的身分符合網路身分 (IP address)，讓現成的應用更容易在 Kubernetes 上執行，應用可以直接使用靜態的常規 port number (例如 HTTP 流量使用 80 port)，現有的工具也可以直接使用，例如網段切分 (network segmentation)、帶寬節流 (bandwidth throttling) 與控制。所有的公有雲都提供每個 Pod 一個 IP 的網路基底，在實體機器 (bare metal)，也可以使用軟體定義網路 (Software defined network) 的 overlay 網路，或是設定 L3 路由來配置機器上的 Pod IPs。&lt;/p&gt;
&lt;h3 id=&#34;不要幫容器編號使用-label-控制容器&#34;&gt;不要幫容器編號，使用 label 控制容器&lt;/h3&gt;
&lt;p&gt;容器建構變得方便後，使用者會產生大量容器，很快就需要一個群組管理的方法。Borg 提供 job 給一組相同的 tasks (task 作為容器的名稱)，一個 job 是一組向量集合 (compact vector) 可以指向一個或多個 tasks，將 task 從 0 開始遞增編號，這個做法很直接也很方便，但等稍後需要重啟容器時，Google 就後悔這個固定的設計，例如其中一個 task 死了需要重啟刀另外一台機器，原本的 task 向量的相同位置，現在需要做兩倍工作：找到新的副本，然後指向舊的副本以免需要除錯。當向量集合中的 task 離開後，這個向量上就有很多空洞，這讓 Borg 上層的管理系統分配，跨級群的 job 時變得很困難。這也造成 Borg 的 job 升級語法中出現許多危險且不可預期的交互 (當滾動升級時依照 index 順序重啟 task)，而應用仰賴 task index (例如應用使用 index 執行資料級的 sharding 或 paritioning)：如果應用使用 task index 來做 sharding，Borg 重啟時會移除鄰近的 tasks，導致資料不可用。Borg 也沒有好方法來增加來自應用的 metadata 到 task 上，例如角色 (e.g. 前端網頁)、或是滾動升級的狀態 (e.g. canary)，工程師只好將 metadata 編碼，壓在 jobs 的名稱上，再使用正規表達式 (regular expression) 解碼。&lt;/p&gt;
&lt;p&gt;Kubernetes 直接使用 label 來辨識容器群，label 是鍵值資料對 (key-value pair)，包含可以辨識應用的資料，一個 Pod 可能有 role=frontend 與 state=production 表示 Pod 是屬於 production 環境的前端網頁。label 可以動態增加，並使用自動化工具更改，個團隊可以自行維護一組各自的 label。使用 label-selector 來取得一組物件 (e.g. stage==production &amp;amp;&amp;amp; role==frontend)。各組物件可以重複，一個物件也可以屬於多個物件組，所以 label 也比靜態的物件清單更有彈性。由於物件組都是動態查詢時產生的，任何時候都可以增加新的物件組。label-selector 是 Kubernetes 的群組機制，並藉此分界管理維運，又可以同時處理多個實體。&lt;/p&gt;
&lt;p&gt;雖然有些使用情形，事先明確知道一組內有哪些 task 很有用 (例如靜態腳色指派、工作 partitioning 或 sharding)，合理的 label 也能產生一樣的效果，只是應用 (或是其他外部管理系統) 就需要負責提供 labeling。label 與 label-selector 為雙邊提供最適的做法。&lt;/p&gt;
&lt;h3 id=&#34;注意-pod-的所有權&#34;&gt;注意 Pod 的所有權&lt;/h3&gt;
&lt;p&gt;Borg 上 task 依賴 job，不會獨自存在，產生 job 時產生 tasks，這些 tasks 永遠連結特定的 job，刪除 job 同時刪除 tasks。這點很方便，但有一個缺陷，這個單一的群組機制，需要應對所有使用需求。例如 一個 job 需要儲存參數，提供給服務或是提供給應用，但不會一起提供，使用者就需要開發取代方案來協助處理 (e.g. DaemonSet 將 Pod 複製到所有節點上)&lt;/p&gt;
&lt;p&gt;Kubernetes 中 Pod 的生命週期管理元件，例如 replication controller，使用 label selector 決定那些 Pod 要負責管理，所以會有一個以上的 controller 認為他們都對某個 Pod 有管轄權，這樣的衝突需要透過明確設定避免的。由於 label 的彈性也有許多優點，例如將 controller 與 Pod 解藕，表示再也不會有以往的孤兒 Pod (orphan) 或是認領的 Pod (adopt)。考慮附載均衡服務，透過 label selector 選擇流量的端點，如果一個 Pod 行為有異，這個 Pod 只要移除對應的 label，Kubernetes service load balancer 就可以避免流量，輕易的被隔離開來，但 Pod 本身還會存在，提供原地除錯。同時，管理 Pod 的 replication controller 會增加一個 Pod 來取代行為有異的 Pod。&lt;/p&gt;
&lt;h3 id=&#34;不要暴露-raw-state&#34;&gt;不要暴露 raw state&lt;/h3&gt;
&lt;p&gt;Borg、Omega、Kubernetes 的關鍵不同點是 API 的架構設計。Borgmaster 是一個集中單一的 (monolithic) 元件，可見所有的 API 行為，包含級群管理邏輯，例如 job 與 task 的狀態機制，並且使用基於 Paxos 算法的分散式儲存庫。Omega 除了儲存庫以外，沒有集中式的元件，儲存庫只儲存被動的狀態資訊，提供樂觀的平行控制 (optimistic concurrenty control)：所有邏輯與語法都推送到儲存庫的客戶端，所以所有客戶端都可以讀取 Omega 的所有邏輯。實務中 Omega 的元件都使用相同的客戶端程式庫，負責打包/解包資料結構、資料重送、並確保語法的一致性。&lt;/p&gt;
&lt;p&gt;Kubernetes 選擇中間，類似 Omega 元件化架構的架構，確保全域的常數、政策控管、資料轉型，來提供彈性與擴容性。Kubernetes 確保所有的儲存庫存取都透過 API server，API server 隱藏儲存庫的實作、負責物件的驗證、除錯、版本控制。如同 Omega，Kubernetes 提供多種不同的客戶端 (特別給是開源的環境)，但是集中化的 API server，仍能確保相同的語法、恆量、與政策控管。&lt;/p&gt;
&lt;h1 id=&#34;其他困難的開放問題&#34;&gt;其他困難的開放問題&lt;/h1&gt;
&lt;p&gt;多年的容器開發系統開發競豔，Google 仍然有一些問題還沒找到合適的答案，這裡分享一些問題，希望能帶來更多討論與解決方案。&lt;/p&gt;
&lt;h3 id=&#34;設定-configuration&#34;&gt;設定 (configuration)&lt;/h3&gt;
&lt;p&gt;所有面對的問題中，與設定 (configuration) 有關的問題，產生最多的腦力激盪、文件、與許多程式碼。一組數值提供給應用，但不是直接寫死在程式碼中，我們可以就此寫一大篇些不完，但這邊先聚焦幾個重點。&lt;/p&gt;
&lt;p&gt;第一，關於應用的設定，容器管理系統沒做，但已經有包羅萬象的實作，Borg 的歷史中包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;範版 (boilerplate) 的精簡 (e.g. 針對不同工作負載，例如服務或是批次任務，提供預設的 task 重啟政策)&lt;/li&gt;
&lt;li&gt;調整並驗證應用的參數與命令列標籤 (command-line flags)&lt;/li&gt;
&lt;li&gt;實作 workaround 給還沒有的 API 抽象，例如 package 管理&lt;/li&gt;
&lt;li&gt;應用的設定樣本程式庫&lt;/li&gt;
&lt;li&gt;發布管理工具 (release management)&lt;/li&gt;
&lt;li&gt;映象檔版本規格&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;為了與上述需求協作，設定管理系統最終產生一套針對特定領域 (domain-specific) 的設定語言，最終變成 Turing 語言，為了在設定資料中進行運算 (e.g. 透過服務的 sharding 數量，還決定調整機器的 memory)，這會造成一種難以理解的設定程式碼 (configuration is code) ，而這是應用工程師，透過消滅原始碼中寫死的參數，盡力避免的。這點並沒有降低維運的複雜性，新的語言只是將設定的運算，從應用的程式語言中，移到另外一個新的特定語言，而這個語言往往更缺乏開發工具、除錯工具、與測試框架。&lt;/p&gt;
&lt;p&gt;Google 認為目前最有效的辦法，是接受一部分無法避免的程式設定，並且清楚的區分運算的程式與資料。呈現資料的語言應該簡單清楚，例如 JSON 或是 YAML，設定運算的邏輯則需要使用完整的程式語言，才有完整的語法、與好的工具。這點可見於 Angular 前端框架，劃分 markup 資料與 JavaScript 運算邏輯。&lt;/p&gt;
&lt;h3 id=&#34;依賴管理-dependency-management&#34;&gt;依賴管理 (dependency management)&lt;/h3&gt;
&lt;p&gt;建立服務往往意味著建立一套相關服務 (監控、CI/CD、等等)，如果一個應用依賴其他應用，是否容器管理系統也能自動提供依賴的服務呢？&lt;/p&gt;
&lt;p&gt;讓事情更複雜，啟動依賴服務往往不只是啟動新的副本，例如服務啟動後還需要向使用者註冊 (例如 BigTable 服務)，然後傳送身分認證、權限認證、以及其他中介服務的計價資訊。沒有一個系統可以捕捉、管理、維護、或是暴露這樣的依賴系統資訊。所以開啟一個新服務時，用戶仍需要自己煩惱、部屬新服務仍然困難，而這往往進一步導致使用者沒有跟隨最佳實踐，進而降低服務的可靠性。&lt;/p&gt;
&lt;p&gt;一個標準問題是，如果服務是手動提供的，跟上依賴服務更新會很困難。試圖自動化判斷 (e.g. 使用 tracing accesses) 失敗，因為無法取得判讀結果所需要的語法資訊。一個可能的解決方法，是要求應用列舉所有依賴的服務，並且透過架構控制，拒絕其他應用存取 (如同編譯時匯入的程式庫)。這樣可以讓容器管理系統提供自動化的環境設定、提供自動身分認證、並寫自動連接。&lt;/p&gt;
&lt;p&gt;不幸的是，這樣描述、分析、使用依賴性的系統太過複雜，還沒被增加到主流的容器管理系統。我們希望有天 Kubernetes 能夠建立起類似的工具，單目前仍是一個尚未完成的挑戰。&lt;/p&gt;
&lt;h1 id=&#34;結論&#34;&gt;結論&lt;/h1&gt;
&lt;p&gt;十年的經驗打掃容器管理系統，給了我們許多經驗，我們將其實作 Kubernetes 上，Kubernetes 的目的是透過容器，提升工程師的生產力，並減輕手動與自動管理系統的負擔，我們希望你也能加入拓展與探索的行列。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2020 IT邦幫忙鐵人賽</title>
      <link>https://chechia.net/en/post/2020-09-09-ithome-ironman-challenge/</link>
      <pubDate>Mon, 09 Sep 2019 16:56:03 +0800</pubDate>
      <guid>https://chechia.net/en/post/2020-09-09-ithome-ironman-challenge/</guid>
      <description>&lt;p&gt;各位好，我是Che-Chia Chang，專長 DevOps &amp;amp; Kubernetes&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://chechia.net&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;今年不保證不爛尾的 2021 鐵人挑戰頁面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.facebook.com/engineer.from.scratch&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;第一手消息發布，免費線上諮詢，請見 FB&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/users/20120327/ironman/2444&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;往年回顧 4 萬餘字的血淚 30 日 - 2020 鐵人挑戰 優等&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;回到 2021 年，本系列會寫得很隨興，讀者有幫助為目的撰寫，&lt;/p&gt;
&lt;p&gt;如果有興趣的題目，或是好奇想問問題，歡迎底下留言，或到&lt;a href=&#34;https://www.facebook.com/engineer.from.scratch&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;我的 FB 私訊&lt;/a&gt;，我都會一對一回復。基於「取之社群回饋社群」的精神，諮詢聊天都是永遠免費。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基於明確需求，討論解決方案&lt;/li&gt;
&lt;li&gt;跟 Kubernetes 有關&lt;/li&gt;
&lt;li&gt;提供手把手 SOP&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;喜歡也請幫我點個讚，或是留言讓我知道，讓我有點動力繼續寫，大幅降低我偷懶爛尾的機率(XD)&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;預定的主題（可能會微調或大改XD）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;好文翻譯分享 Borg, Omega, Kubernetes - Google 容器化開發十年經驗，Kubernetes 的前日今生&lt;/li&gt;
&lt;li&gt;公有雲省錢大作戰 - 我這邊有一批便宜的好 VM 打三折賣你，Preemptible / Spot Instance 先占節點實戰分享
&lt;ul&gt;
&lt;li&gt;公有雲省錢大作戰 - Preemptible / Spot Instance 先占節點，原理簡介與規格&lt;/li&gt;
&lt;li&gt;公有雲省錢大作戰 - Preemptible / Spot Instance 先占節點，適用案例實戰分析&lt;/li&gt;
&lt;li&gt;公有雲省錢大作戰 - Preemptible / Spot Instance 先占節點，使用範例&lt;/li&gt;
&lt;li&gt;公有雲省錢大作戰 - Preemptible / Spot Instance 先占節點，經驗分享，雷點&lt;/li&gt;
&lt;li&gt;公有雲省錢大作戰 - 我跑了一個 bot，24 小時上線， GCP 一天收你 4 元台幣&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;大家都來用 Terraform，Infrastructure as Code 演講全文分享
&lt;ul&gt;
&lt;li&gt;iThome Cloud Summit 講到時間超過，一對東西沒講，所以來這邊發文&lt;/li&gt;
&lt;li&gt;真的好用，實戰經驗分享&lt;/li&gt;
&lt;li&gt;解答粉專私訊問題與觀眾發問&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分散式工具實驗室 - Scalable Database on Kubernetes
&lt;ul&gt;
&lt;li&gt;Thanos - Scalable HA Prometheus
&lt;ul&gt;
&lt;li&gt;簡介&lt;/li&gt;
&lt;li&gt;需求分析，Unlimited Retention 鐵一般的需求&lt;/li&gt;
&lt;li&gt;一步步帶你架&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Scalable DB 實驗- Cockroach DB - 耐用打不死又高效能的小強資料庫
&lt;ul&gt;
&lt;li&gt;前言，分散式系統下的困境，資料庫瓶頸&lt;/li&gt;
&lt;li&gt;Cockroach DB 基本原理簡介&lt;/li&gt;
&lt;li&gt;Cockroach DB Free Trial 玩起來&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Cassandra - 支撐百萬級寫入的分散式資料庫
&lt;ul&gt;
&lt;li&gt;Cassandra 簡介&lt;/li&gt;
&lt;li&gt;Cassandra 細部原理，分散式的資料庫設計超好玩&lt;/li&gt;
&lt;li&gt;Cassandra 細部原理，Consistency Hashing&lt;/li&gt;
&lt;li&gt;Cassandra 細部原理，Data modeling&lt;/li&gt;
&lt;li&gt;Netflix case study - 偷學 Netflix 能學到幾成功力呢&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有任何謬誤，還煩請各方大德&amp;lt;3聯絡我，感激不盡。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
